// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/billc-dev/tuango-go/ent/comment"
	"github.com/billc-dev/tuango-go/ent/complete"
	"github.com/billc-dev/tuango-go/ent/deliver"
	"github.com/billc-dev/tuango-go/ent/like"
	"github.com/billc-dev/tuango-go/ent/message"
	"github.com/billc-dev/tuango-go/ent/notification"
	"github.com/billc-dev/tuango-go/ent/notify"
	"github.com/billc-dev/tuango-go/ent/order"
	"github.com/billc-dev/tuango-go/ent/orderhistory"
	"github.com/billc-dev/tuango-go/ent/orderitem"
	"github.com/billc-dev/tuango-go/ent/post"
	"github.com/billc-dev/tuango-go/ent/postitem"
	"github.com/billc-dev/tuango-go/ent/predicate"
	"github.com/billc-dev/tuango-go/ent/room"
	"github.com/billc-dev/tuango-go/ent/roomuser"
	"github.com/billc-dev/tuango-go/ent/schema"
	"github.com/billc-dev/tuango-go/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment      = "Comment"
	TypeComplete     = "Complete"
	TypeDeliver      = "Deliver"
	TypeLike         = "Like"
	TypeMessage      = "Message"
	TypeNotification = "Notification"
	TypeNotify       = "Notify"
	TypeOrder        = "Order"
	TypeOrderHistory = "OrderHistory"
	TypeOrderItem    = "OrderItem"
	TypePost         = "Post"
	TypePostItem     = "PostItem"
	TypeRoom         = "Room"
	TypeRoomUser     = "RoomUser"
	TypeUser         = "User"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	comment       *string
	replies       *[]schema.Reply
	appendreplies []schema.Reply
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	post          *string
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *CommentMutation) SetPostID(s string) {
	m.post = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CommentMutation) PostID() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CommentMutation) ResetPostID() {
	m.post = nil
}

// SetComment sets the "comment" field.
func (m *CommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *CommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *CommentMutation) ResetComment() {
	m.comment = nil
}

// SetReplies sets the "replies" field.
func (m *CommentMutation) SetReplies(s []schema.Reply) {
	m.replies = &s
	m.appendreplies = nil
}

// Replies returns the value of the "replies" field in the mutation.
func (m *CommentMutation) Replies() (r []schema.Reply, exists bool) {
	v := m.replies
	if v == nil {
		return
	}
	return *v, true
}

// OldReplies returns the old "replies" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplies(ctx context.Context) (v []schema.Reply, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplies: %w", err)
	}
	return oldValue.Replies, nil
}

// AppendReplies adds s to the "replies" field.
func (m *CommentMutation) AppendReplies(s []schema.Reply) {
	m.appendreplies = append(m.appendreplies, s...)
}

// AppendedReplies returns the list of values that were appended to the "replies" field in this mutation.
func (m *CommentMutation) AppendedReplies() ([]schema.Reply, bool) {
	if len(m.appendreplies) == 0 {
		return nil, false
	}
	return m.appendreplies, true
}

// ResetReplies resets all changes to the "replies" field.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.appendreplies = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[comment.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.post != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.comment != nil {
		fields = append(fields, comment.FieldComment)
	}
	if m.replies != nil {
		fields = append(fields, comment.FieldReplies)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldPostID:
		return m.PostID()
	case comment.FieldComment:
		return m.Comment()
	case comment.FieldReplies:
		return m.Replies()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldPostID:
		return m.OldPostID(ctx)
	case comment.FieldComment:
		return m.OldComment(ctx)
	case comment.FieldReplies:
		return m.OldReplies(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case comment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case comment.FieldReplies:
		v, ok := value.([]schema.Reply)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplies(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldPostID:
		m.ResetPostID()
		return nil
	case comment.FieldComment:
		m.ResetComment()
		return nil
	case comment.FieldReplies:
		m.ResetReplies()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CompleteMutation represents an operation that mutates the Complete nodes in the graph.
type CompleteMutation struct {
	config
	op            Op
	typ           string
	id            *string
	total         *float64
	addtotal      *float64
	admin         *string
	line_pay      *bool
	confirmed     *bool
	orders        *[]schema.CompleteOrder
	appendorders  []schema.CompleteOrder
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Complete, error)
	predicates    []predicate.Complete
}

var _ ent.Mutation = (*CompleteMutation)(nil)

// completeOption allows management of the mutation configuration using functional options.
type completeOption func(*CompleteMutation)

// newCompleteMutation creates new mutation for the Complete entity.
func newCompleteMutation(c config, op Op, opts ...completeOption) *CompleteMutation {
	m := &CompleteMutation{
		config:        c,
		op:            op,
		typ:           TypeComplete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompleteID sets the ID field of the mutation.
func withCompleteID(id string) completeOption {
	return func(m *CompleteMutation) {
		var (
			err   error
			once  sync.Once
			value *Complete
		)
		m.oldValue = func(ctx context.Context) (*Complete, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Complete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComplete sets the old Complete of the mutation.
func withComplete(node *Complete) completeOption {
	return func(m *CompleteMutation) {
		m.oldValue = func(context.Context) (*Complete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Complete entities.
func (m *CompleteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompleteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompleteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Complete.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CompleteMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CompleteMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CompleteMutation) ResetUserID() {
	m.user = nil
}

// SetTotal sets the "total" field.
func (m *CompleteMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *CompleteMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *CompleteMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *CompleteMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *CompleteMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetAdmin sets the "admin" field.
func (m *CompleteMutation) SetAdmin(s string) {
	m.admin = &s
}

// Admin returns the value of the "admin" field in the mutation.
func (m *CompleteMutation) Admin() (r string, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldAdmin(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *CompleteMutation) ResetAdmin() {
	m.admin = nil
}

// SetLinePay sets the "line_pay" field.
func (m *CompleteMutation) SetLinePay(b bool) {
	m.line_pay = &b
}

// LinePay returns the value of the "line_pay" field in the mutation.
func (m *CompleteMutation) LinePay() (r bool, exists bool) {
	v := m.line_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldLinePay returns the old "line_pay" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldLinePay(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinePay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinePay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinePay: %w", err)
	}
	return oldValue.LinePay, nil
}

// ResetLinePay resets all changes to the "line_pay" field.
func (m *CompleteMutation) ResetLinePay() {
	m.line_pay = nil
}

// SetConfirmed sets the "confirmed" field.
func (m *CompleteMutation) SetConfirmed(b bool) {
	m.confirmed = &b
}

// Confirmed returns the value of the "confirmed" field in the mutation.
func (m *CompleteMutation) Confirmed() (r bool, exists bool) {
	v := m.confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmed returns the old "confirmed" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldConfirmed(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmed: %w", err)
	}
	return oldValue.Confirmed, nil
}

// ResetConfirmed resets all changes to the "confirmed" field.
func (m *CompleteMutation) ResetConfirmed() {
	m.confirmed = nil
}

// SetOrders sets the "orders" field.
func (m *CompleteMutation) SetOrders(so []schema.CompleteOrder) {
	m.orders = &so
	m.appendorders = nil
}

// Orders returns the value of the "orders" field in the mutation.
func (m *CompleteMutation) Orders() (r []schema.CompleteOrder, exists bool) {
	v := m.orders
	if v == nil {
		return
	}
	return *v, true
}

// OldOrders returns the old "orders" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldOrders(ctx context.Context) (v []schema.CompleteOrder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrders: %w", err)
	}
	return oldValue.Orders, nil
}

// AppendOrders adds so to the "orders" field.
func (m *CompleteMutation) AppendOrders(so []schema.CompleteOrder) {
	m.appendorders = append(m.appendorders, so...)
}

// AppendedOrders returns the list of values that were appended to the "orders" field in this mutation.
func (m *CompleteMutation) AppendedOrders() ([]schema.CompleteOrder, bool) {
	if len(m.appendorders) == 0 {
		return nil, false
	}
	return m.appendorders, true
}

// ResetOrders resets all changes to the "orders" field.
func (m *CompleteMutation) ResetOrders() {
	m.orders = nil
	m.appendorders = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CompleteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompleteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Complete entity.
// If the Complete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompleteMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompleteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CompleteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[complete.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CompleteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CompleteMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CompleteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CompleteMutation builder.
func (m *CompleteMutation) Where(ps ...predicate.Complete) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompleteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompleteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Complete, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompleteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompleteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Complete).
func (m *CompleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompleteMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, complete.FieldUserID)
	}
	if m.total != nil {
		fields = append(fields, complete.FieldTotal)
	}
	if m.admin != nil {
		fields = append(fields, complete.FieldAdmin)
	}
	if m.line_pay != nil {
		fields = append(fields, complete.FieldLinePay)
	}
	if m.confirmed != nil {
		fields = append(fields, complete.FieldConfirmed)
	}
	if m.orders != nil {
		fields = append(fields, complete.FieldOrders)
	}
	if m.created_at != nil {
		fields = append(fields, complete.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case complete.FieldUserID:
		return m.UserID()
	case complete.FieldTotal:
		return m.Total()
	case complete.FieldAdmin:
		return m.Admin()
	case complete.FieldLinePay:
		return m.LinePay()
	case complete.FieldConfirmed:
		return m.Confirmed()
	case complete.FieldOrders:
		return m.Orders()
	case complete.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case complete.FieldUserID:
		return m.OldUserID(ctx)
	case complete.FieldTotal:
		return m.OldTotal(ctx)
	case complete.FieldAdmin:
		return m.OldAdmin(ctx)
	case complete.FieldLinePay:
		return m.OldLinePay(ctx)
	case complete.FieldConfirmed:
		return m.OldConfirmed(ctx)
	case complete.FieldOrders:
		return m.OldOrders(ctx)
	case complete.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Complete field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case complete.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case complete.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case complete.FieldAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case complete.FieldLinePay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinePay(v)
		return nil
	case complete.FieldConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmed(v)
		return nil
	case complete.FieldOrders:
		v, ok := value.([]schema.CompleteOrder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrders(v)
		return nil
	case complete.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Complete field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompleteMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, complete.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompleteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case complete.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case complete.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Complete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompleteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompleteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Complete nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompleteMutation) ResetField(name string) error {
	switch name {
	case complete.FieldUserID:
		m.ResetUserID()
		return nil
	case complete.FieldTotal:
		m.ResetTotal()
		return nil
	case complete.FieldAdmin:
		m.ResetAdmin()
		return nil
	case complete.FieldLinePay:
		m.ResetLinePay()
		return nil
	case complete.FieldConfirmed:
		m.ResetConfirmed()
		return nil
	case complete.FieldOrders:
		m.ResetOrders()
		return nil
	case complete.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Complete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, complete.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case complete.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompleteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, complete.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompleteMutation) EdgeCleared(name string) bool {
	switch name {
	case complete.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompleteMutation) ClearEdge(name string) error {
	switch name {
	case complete.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Complete unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompleteMutation) ResetEdge(name string) error {
	switch name {
	case complete.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Complete edge %s", name)
}

// DeliverMutation represents an operation that mutates the Deliver nodes in the graph.
type DeliverMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	normal_orders       *[]schema.DeliverOrder
	appendnormal_orders []schema.DeliverOrder
	extra_orders        *[]schema.DeliverOrder
	appendextra_orders  []schema.DeliverOrder
	normal_total        *float64
	addnormal_total     *float64
	normal_fee          *float64
	addnormal_fee       *float64
	extra_total         *float64
	addextra_total      *float64
	extra_fee           *float64
	addextra_fee        *float64
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	post                *string
	clearedpost         bool
	done                bool
	oldValue            func(context.Context) (*Deliver, error)
	predicates          []predicate.Deliver
}

var _ ent.Mutation = (*DeliverMutation)(nil)

// deliverOption allows management of the mutation configuration using functional options.
type deliverOption func(*DeliverMutation)

// newDeliverMutation creates new mutation for the Deliver entity.
func newDeliverMutation(c config, op Op, opts ...deliverOption) *DeliverMutation {
	m := &DeliverMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliver,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliverID sets the ID field of the mutation.
func withDeliverID(id string) deliverOption {
	return func(m *DeliverMutation) {
		var (
			err   error
			once  sync.Once
			value *Deliver
		)
		m.oldValue = func(ctx context.Context) (*Deliver, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deliver.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliver sets the old Deliver of the mutation.
func withDeliver(node *Deliver) deliverOption {
	return func(m *DeliverMutation) {
		m.oldValue = func(context.Context) (*Deliver, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Deliver entities.
func (m *DeliverMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliverMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliverMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deliver.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *DeliverMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeliverMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeliverMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *DeliverMutation) SetPostID(s string) {
	m.post = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *DeliverMutation) PostID() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *DeliverMutation) ResetPostID() {
	m.post = nil
}

// SetNormalOrders sets the "normal_orders" field.
func (m *DeliverMutation) SetNormalOrders(so []schema.DeliverOrder) {
	m.normal_orders = &so
	m.appendnormal_orders = nil
}

// NormalOrders returns the value of the "normal_orders" field in the mutation.
func (m *DeliverMutation) NormalOrders() (r []schema.DeliverOrder, exists bool) {
	v := m.normal_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalOrders returns the old "normal_orders" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldNormalOrders(ctx context.Context) (v []schema.DeliverOrder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalOrders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalOrders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalOrders: %w", err)
	}
	return oldValue.NormalOrders, nil
}

// AppendNormalOrders adds so to the "normal_orders" field.
func (m *DeliverMutation) AppendNormalOrders(so []schema.DeliverOrder) {
	m.appendnormal_orders = append(m.appendnormal_orders, so...)
}

// AppendedNormalOrders returns the list of values that were appended to the "normal_orders" field in this mutation.
func (m *DeliverMutation) AppendedNormalOrders() ([]schema.DeliverOrder, bool) {
	if len(m.appendnormal_orders) == 0 {
		return nil, false
	}
	return m.appendnormal_orders, true
}

// ResetNormalOrders resets all changes to the "normal_orders" field.
func (m *DeliverMutation) ResetNormalOrders() {
	m.normal_orders = nil
	m.appendnormal_orders = nil
}

// SetExtraOrders sets the "extra_orders" field.
func (m *DeliverMutation) SetExtraOrders(so []schema.DeliverOrder) {
	m.extra_orders = &so
	m.appendextra_orders = nil
}

// ExtraOrders returns the value of the "extra_orders" field in the mutation.
func (m *DeliverMutation) ExtraOrders() (r []schema.DeliverOrder, exists bool) {
	v := m.extra_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraOrders returns the old "extra_orders" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldExtraOrders(ctx context.Context) (v []schema.DeliverOrder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraOrders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraOrders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraOrders: %w", err)
	}
	return oldValue.ExtraOrders, nil
}

// AppendExtraOrders adds so to the "extra_orders" field.
func (m *DeliverMutation) AppendExtraOrders(so []schema.DeliverOrder) {
	m.appendextra_orders = append(m.appendextra_orders, so...)
}

// AppendedExtraOrders returns the list of values that were appended to the "extra_orders" field in this mutation.
func (m *DeliverMutation) AppendedExtraOrders() ([]schema.DeliverOrder, bool) {
	if len(m.appendextra_orders) == 0 {
		return nil, false
	}
	return m.appendextra_orders, true
}

// ResetExtraOrders resets all changes to the "extra_orders" field.
func (m *DeliverMutation) ResetExtraOrders() {
	m.extra_orders = nil
	m.appendextra_orders = nil
}

// SetNormalTotal sets the "normal_total" field.
func (m *DeliverMutation) SetNormalTotal(f float64) {
	m.normal_total = &f
	m.addnormal_total = nil
}

// NormalTotal returns the value of the "normal_total" field in the mutation.
func (m *DeliverMutation) NormalTotal() (r float64, exists bool) {
	v := m.normal_total
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTotal returns the old "normal_total" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldNormalTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTotal: %w", err)
	}
	return oldValue.NormalTotal, nil
}

// AddNormalTotal adds f to the "normal_total" field.
func (m *DeliverMutation) AddNormalTotal(f float64) {
	if m.addnormal_total != nil {
		*m.addnormal_total += f
	} else {
		m.addnormal_total = &f
	}
}

// AddedNormalTotal returns the value that was added to the "normal_total" field in this mutation.
func (m *DeliverMutation) AddedNormalTotal() (r float64, exists bool) {
	v := m.addnormal_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTotal resets all changes to the "normal_total" field.
func (m *DeliverMutation) ResetNormalTotal() {
	m.normal_total = nil
	m.addnormal_total = nil
}

// SetNormalFee sets the "normal_fee" field.
func (m *DeliverMutation) SetNormalFee(f float64) {
	m.normal_fee = &f
	m.addnormal_fee = nil
}

// NormalFee returns the value of the "normal_fee" field in the mutation.
func (m *DeliverMutation) NormalFee() (r float64, exists bool) {
	v := m.normal_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalFee returns the old "normal_fee" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldNormalFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalFee: %w", err)
	}
	return oldValue.NormalFee, nil
}

// AddNormalFee adds f to the "normal_fee" field.
func (m *DeliverMutation) AddNormalFee(f float64) {
	if m.addnormal_fee != nil {
		*m.addnormal_fee += f
	} else {
		m.addnormal_fee = &f
	}
}

// AddedNormalFee returns the value that was added to the "normal_fee" field in this mutation.
func (m *DeliverMutation) AddedNormalFee() (r float64, exists bool) {
	v := m.addnormal_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalFee resets all changes to the "normal_fee" field.
func (m *DeliverMutation) ResetNormalFee() {
	m.normal_fee = nil
	m.addnormal_fee = nil
}

// SetExtraTotal sets the "extra_total" field.
func (m *DeliverMutation) SetExtraTotal(f float64) {
	m.extra_total = &f
	m.addextra_total = nil
}

// ExtraTotal returns the value of the "extra_total" field in the mutation.
func (m *DeliverMutation) ExtraTotal() (r float64, exists bool) {
	v := m.extra_total
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraTotal returns the old "extra_total" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldExtraTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraTotal: %w", err)
	}
	return oldValue.ExtraTotal, nil
}

// AddExtraTotal adds f to the "extra_total" field.
func (m *DeliverMutation) AddExtraTotal(f float64) {
	if m.addextra_total != nil {
		*m.addextra_total += f
	} else {
		m.addextra_total = &f
	}
}

// AddedExtraTotal returns the value that was added to the "extra_total" field in this mutation.
func (m *DeliverMutation) AddedExtraTotal() (r float64, exists bool) {
	v := m.addextra_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtraTotal resets all changes to the "extra_total" field.
func (m *DeliverMutation) ResetExtraTotal() {
	m.extra_total = nil
	m.addextra_total = nil
}

// SetExtraFee sets the "extra_fee" field.
func (m *DeliverMutation) SetExtraFee(f float64) {
	m.extra_fee = &f
	m.addextra_fee = nil
}

// ExtraFee returns the value of the "extra_fee" field in the mutation.
func (m *DeliverMutation) ExtraFee() (r float64, exists bool) {
	v := m.extra_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraFee returns the old "extra_fee" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldExtraFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraFee: %w", err)
	}
	return oldValue.ExtraFee, nil
}

// AddExtraFee adds f to the "extra_fee" field.
func (m *DeliverMutation) AddExtraFee(f float64) {
	if m.addextra_fee != nil {
		*m.addextra_fee += f
	} else {
		m.addextra_fee = &f
	}
}

// AddedExtraFee returns the value that was added to the "extra_fee" field in this mutation.
func (m *DeliverMutation) AddedExtraFee() (r float64, exists bool) {
	v := m.addextra_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtraFee resets all changes to the "extra_fee" field.
func (m *DeliverMutation) ResetExtraFee() {
	m.extra_fee = nil
	m.addextra_fee = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeliverMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeliverMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeliverMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeliverMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeliverMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Deliver entity.
// If the Deliver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeliverMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeliverMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[deliver.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeliverMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeliverMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeliverMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *DeliverMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[deliver.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *DeliverMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *DeliverMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *DeliverMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the DeliverMutation builder.
func (m *DeliverMutation) Where(ps ...predicate.Deliver) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Deliver, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Deliver).
func (m *DeliverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliverMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, deliver.FieldUserID)
	}
	if m.post != nil {
		fields = append(fields, deliver.FieldPostID)
	}
	if m.normal_orders != nil {
		fields = append(fields, deliver.FieldNormalOrders)
	}
	if m.extra_orders != nil {
		fields = append(fields, deliver.FieldExtraOrders)
	}
	if m.normal_total != nil {
		fields = append(fields, deliver.FieldNormalTotal)
	}
	if m.normal_fee != nil {
		fields = append(fields, deliver.FieldNormalFee)
	}
	if m.extra_total != nil {
		fields = append(fields, deliver.FieldExtraTotal)
	}
	if m.extra_fee != nil {
		fields = append(fields, deliver.FieldExtraFee)
	}
	if m.created_at != nil {
		fields = append(fields, deliver.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deliver.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliver.FieldUserID:
		return m.UserID()
	case deliver.FieldPostID:
		return m.PostID()
	case deliver.FieldNormalOrders:
		return m.NormalOrders()
	case deliver.FieldExtraOrders:
		return m.ExtraOrders()
	case deliver.FieldNormalTotal:
		return m.NormalTotal()
	case deliver.FieldNormalFee:
		return m.NormalFee()
	case deliver.FieldExtraTotal:
		return m.ExtraTotal()
	case deliver.FieldExtraFee:
		return m.ExtraFee()
	case deliver.FieldCreatedAt:
		return m.CreatedAt()
	case deliver.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliver.FieldUserID:
		return m.OldUserID(ctx)
	case deliver.FieldPostID:
		return m.OldPostID(ctx)
	case deliver.FieldNormalOrders:
		return m.OldNormalOrders(ctx)
	case deliver.FieldExtraOrders:
		return m.OldExtraOrders(ctx)
	case deliver.FieldNormalTotal:
		return m.OldNormalTotal(ctx)
	case deliver.FieldNormalFee:
		return m.OldNormalFee(ctx)
	case deliver.FieldExtraTotal:
		return m.OldExtraTotal(ctx)
	case deliver.FieldExtraFee:
		return m.OldExtraFee(ctx)
	case deliver.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deliver.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Deliver field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliver.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case deliver.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case deliver.FieldNormalOrders:
		v, ok := value.([]schema.DeliverOrder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalOrders(v)
		return nil
	case deliver.FieldExtraOrders:
		v, ok := value.([]schema.DeliverOrder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraOrders(v)
		return nil
	case deliver.FieldNormalTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTotal(v)
		return nil
	case deliver.FieldNormalFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalFee(v)
		return nil
	case deliver.FieldExtraTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraTotal(v)
		return nil
	case deliver.FieldExtraFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraFee(v)
		return nil
	case deliver.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deliver.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Deliver field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliverMutation) AddedFields() []string {
	var fields []string
	if m.addnormal_total != nil {
		fields = append(fields, deliver.FieldNormalTotal)
	}
	if m.addnormal_fee != nil {
		fields = append(fields, deliver.FieldNormalFee)
	}
	if m.addextra_total != nil {
		fields = append(fields, deliver.FieldExtraTotal)
	}
	if m.addextra_fee != nil {
		fields = append(fields, deliver.FieldExtraFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliverMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliver.FieldNormalTotal:
		return m.AddedNormalTotal()
	case deliver.FieldNormalFee:
		return m.AddedNormalFee()
	case deliver.FieldExtraTotal:
		return m.AddedExtraTotal()
	case deliver.FieldExtraFee:
		return m.AddedExtraFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliverMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliver.FieldNormalTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTotal(v)
		return nil
	case deliver.FieldNormalFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalFee(v)
		return nil
	case deliver.FieldExtraTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraTotal(v)
		return nil
	case deliver.FieldExtraFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraFee(v)
		return nil
	}
	return fmt.Errorf("unknown Deliver numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliverMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliverMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deliver nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliverMutation) ResetField(name string) error {
	switch name {
	case deliver.FieldUserID:
		m.ResetUserID()
		return nil
	case deliver.FieldPostID:
		m.ResetPostID()
		return nil
	case deliver.FieldNormalOrders:
		m.ResetNormalOrders()
		return nil
	case deliver.FieldExtraOrders:
		m.ResetExtraOrders()
		return nil
	case deliver.FieldNormalTotal:
		m.ResetNormalTotal()
		return nil
	case deliver.FieldNormalFee:
		m.ResetNormalFee()
		return nil
	case deliver.FieldExtraTotal:
		m.ResetExtraTotal()
		return nil
	case deliver.FieldExtraFee:
		m.ResetExtraFee()
		return nil
	case deliver.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deliver.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Deliver field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliverMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, deliver.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, deliver.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliver.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case deliver.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliverMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, deliver.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, deliver.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliverMutation) EdgeCleared(name string) bool {
	switch name {
	case deliver.EdgeUser:
		return m.cleareduser
	case deliver.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliverMutation) ClearEdge(name string) error {
	switch name {
	case deliver.EdgeUser:
		m.ClearUser()
		return nil
	case deliver.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Deliver unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliverMutation) ResetEdge(name string) error {
	switch name {
	case deliver.EdgeUser:
		m.ResetUser()
		return nil
	case deliver.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Deliver edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	post          *string
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id string) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *LikeMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LikeMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LikeMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *LikeMutation) SetPostID(s string) {
	m.post = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *LikeMutation) PostID() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *LikeMutation) ResetPostID() {
	m.post = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[like.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *LikeMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[like.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *LikeMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *LikeMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Like, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, like.FieldUserID)
	}
	if m.post != nil {
		fields = append(fields, like.FieldPostID)
	}
	if m.created_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldUserID:
		return m.UserID()
	case like.FieldPostID:
		return m.PostID()
	case like.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldUserID:
		return m.OldUserID(ctx)
	case like.FieldPostID:
		return m.OldPostID(ctx)
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case like.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case like.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldUserID:
		m.ResetUserID()
		return nil
	case like.FieldPostID:
		m.ResetPostID()
		return nil
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, like.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case like.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, like.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	switch name {
	case like.EdgeUser:
		return m.cleareduser
	case like.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ClearUser()
		return nil
	case like.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ResetUser()
		return nil
	case like.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Like edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	post_id       *string
	order_id      *string
	text          *string
	image         *schema.Image
	unsent        *bool
	_type         *message.Type
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	room          *string
	clearedroom   bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id string) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomID sets the "room_id" field.
func (m *MessageMutation) SetRoomID(s string) {
	m.room = &s
}

// RoomID returns the value of the "room_id" field in the mutation.
func (m *MessageMutation) RoomID() (r string, exists bool) {
	v := m.room
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomID returns the old "room_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRoomID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomID: %w", err)
	}
	return oldValue.RoomID, nil
}

// ResetRoomID resets all changes to the "room_id" field.
func (m *MessageMutation) ResetRoomID() {
	m.room = nil
}

// SetUserID sets the "user_id" field.
func (m *MessageMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MessageMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MessageMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *MessageMutation) SetPostID(s string) {
	m.post_id = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *MessageMutation) PostID() (r string, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ClearPostID clears the value of the "post_id" field.
func (m *MessageMutation) ClearPostID() {
	m.post_id = nil
	m.clearedFields[message.FieldPostID] = struct{}{}
}

// PostIDCleared returns if the "post_id" field was cleared in this mutation.
func (m *MessageMutation) PostIDCleared() bool {
	_, ok := m.clearedFields[message.FieldPostID]
	return ok
}

// ResetPostID resets all changes to the "post_id" field.
func (m *MessageMutation) ResetPostID() {
	m.post_id = nil
	delete(m.clearedFields, message.FieldPostID)
}

// SetOrderID sets the "order_id" field.
func (m *MessageMutation) SetOrderID(s string) {
	m.order_id = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MessageMutation) OrderID() (r string, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MessageMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[message.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MessageMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[message.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MessageMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, message.FieldOrderID)
}

// SetText sets the "text" field.
func (m *MessageMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *MessageMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ClearText clears the value of the "text" field.
func (m *MessageMutation) ClearText() {
	m.text = nil
	m.clearedFields[message.FieldText] = struct{}{}
}

// TextCleared returns if the "text" field was cleared in this mutation.
func (m *MessageMutation) TextCleared() bool {
	_, ok := m.clearedFields[message.FieldText]
	return ok
}

// ResetText resets all changes to the "text" field.
func (m *MessageMutation) ResetText() {
	m.text = nil
	delete(m.clearedFields, message.FieldText)
}

// SetImage sets the "image" field.
func (m *MessageMutation) SetImage(s schema.Image) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *MessageMutation) Image() (r schema.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldImage(ctx context.Context) (v schema.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *MessageMutation) ClearImage() {
	m.image = nil
	m.clearedFields[message.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *MessageMutation) ImageCleared() bool {
	_, ok := m.clearedFields[message.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *MessageMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, message.FieldImage)
}

// SetUnsent sets the "unsent" field.
func (m *MessageMutation) SetUnsent(b bool) {
	m.unsent = &b
}

// Unsent returns the value of the "unsent" field in the mutation.
func (m *MessageMutation) Unsent() (r bool, exists bool) {
	v := m.unsent
	if v == nil {
		return
	}
	return *v, true
}

// OldUnsent returns the old "unsent" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUnsent(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnsent: %w", err)
	}
	return oldValue.Unsent, nil
}

// ResetUnsent resets all changes to the "unsent" field.
func (m *MessageMutation) ResetUnsent() {
	m.unsent = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(value message.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r message.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v *message.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *MessageMutation) ClearRoom() {
	m.clearedroom = true
	m.clearedFields[message.FieldRoomID] = struct{}{}
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *MessageMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) RoomIDs() (ids []string) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *MessageMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[message.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.room != nil {
		fields = append(fields, message.FieldRoomID)
	}
	if m.user != nil {
		fields = append(fields, message.FieldUserID)
	}
	if m.post_id != nil {
		fields = append(fields, message.FieldPostID)
	}
	if m.order_id != nil {
		fields = append(fields, message.FieldOrderID)
	}
	if m.text != nil {
		fields = append(fields, message.FieldText)
	}
	if m.image != nil {
		fields = append(fields, message.FieldImage)
	}
	if m.unsent != nil {
		fields = append(fields, message.FieldUnsent)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldRoomID:
		return m.RoomID()
	case message.FieldUserID:
		return m.UserID()
	case message.FieldPostID:
		return m.PostID()
	case message.FieldOrderID:
		return m.OrderID()
	case message.FieldText:
		return m.Text()
	case message.FieldImage:
		return m.Image()
	case message.FieldUnsent:
		return m.Unsent()
	case message.FieldType:
		return m.GetType()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldRoomID:
		return m.OldRoomID(ctx)
	case message.FieldUserID:
		return m.OldUserID(ctx)
	case message.FieldPostID:
		return m.OldPostID(ctx)
	case message.FieldOrderID:
		return m.OldOrderID(ctx)
	case message.FieldText:
		return m.OldText(ctx)
	case message.FieldImage:
		return m.OldImage(ctx)
	case message.FieldUnsent:
		return m.OldUnsent(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldRoomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomID(v)
		return nil
	case message.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case message.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case message.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case message.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case message.FieldImage:
		v, ok := value.(schema.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case message.FieldUnsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnsent(v)
		return nil
	case message.FieldType:
		v, ok := value.(message.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldPostID) {
		fields = append(fields, message.FieldPostID)
	}
	if m.FieldCleared(message.FieldOrderID) {
		fields = append(fields, message.FieldOrderID)
	}
	if m.FieldCleared(message.FieldText) {
		fields = append(fields, message.FieldText)
	}
	if m.FieldCleared(message.FieldImage) {
		fields = append(fields, message.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldPostID:
		m.ClearPostID()
		return nil
	case message.FieldOrderID:
		m.ClearOrderID()
		return nil
	case message.FieldText:
		m.ClearText()
		return nil
	case message.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldRoomID:
		m.ResetRoomID()
		return nil
	case message.FieldUserID:
		m.ResetUserID()
		return nil
	case message.FieldPostID:
		m.ResetPostID()
		return nil
	case message.FieldOrderID:
		m.ResetOrderID()
		return nil
	case message.FieldText:
		m.ResetText()
		return nil
	case message.FieldImage:
		m.ResetImage()
		return nil
	case message.FieldUnsent:
		m.ResetUnsent()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room != nil {
		edges = append(edges, message.EdgeRoom)
	}
	if m.user != nil {
		edges = append(edges, message.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom {
		edges = append(edges, message.EdgeRoom)
	}
	if m.cleareduser {
		edges = append(edges, message.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeRoom:
		return m.clearedroom
	case message.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeRoom:
		m.ClearRoom()
		return nil
	case message.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeRoom:
		m.ResetRoom()
		return nil
	case message.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *string
	text          *string
	query         *schema.NotificationQuery
	users         *[]string
	appendusers   []string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id string) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *NotificationMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NotificationMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NotificationMutation) ResetText() {
	m.text = nil
}

// SetQuery sets the "query" field.
func (m *NotificationMutation) SetQuery(sq schema.NotificationQuery) {
	m.query = &sq
}

// Query returns the value of the "query" field in the mutation.
func (m *NotificationMutation) Query() (r schema.NotificationQuery, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldQuery(ctx context.Context) (v schema.NotificationQuery, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ResetQuery resets all changes to the "query" field.
func (m *NotificationMutation) ResetQuery() {
	m.query = nil
}

// SetUsers sets the "users" field.
func (m *NotificationMutation) SetUsers(s []string) {
	m.users = &s
	m.appendusers = nil
}

// Users returns the value of the "users" field in the mutation.
func (m *NotificationMutation) Users() (r []string, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUsers returns the old "users" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsers: %w", err)
	}
	return oldValue.Users, nil
}

// AppendUsers adds s to the "users" field.
func (m *NotificationMutation) AppendUsers(s []string) {
	m.appendusers = append(m.appendusers, s...)
}

// AppendedUsers returns the list of values that were appended to the "users" field in this mutation.
func (m *NotificationMutation) AppendedUsers() ([]string, bool) {
	if len(m.appendusers) == 0 {
		return nil, false
	}
	return m.appendusers, true
}

// ResetUsers resets all changes to the "users" field.
func (m *NotificationMutation) ResetUsers() {
	m.users = nil
	m.appendusers = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.text != nil {
		fields = append(fields, notification.FieldText)
	}
	if m.query != nil {
		fields = append(fields, notification.FieldQuery)
	}
	if m.users != nil {
		fields = append(fields, notification.FieldUsers)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldText:
		return m.Text()
	case notification.FieldQuery:
		return m.Query()
	case notification.FieldUsers:
		return m.Users()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldText:
		return m.OldText(ctx)
	case notification.FieldQuery:
		return m.OldQuery(ctx)
	case notification.FieldUsers:
		return m.OldUsers(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case notification.FieldQuery:
		v, ok := value.(schema.NotificationQuery)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case notification.FieldUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsers(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldText:
		m.ResetText()
		return nil
	case notification.FieldQuery:
		m.ResetQuery()
		return nil
	case notification.FieldUsers:
		m.ResetUsers()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// NotifyMutation represents an operation that mutates the Notify nodes in the graph.
type NotifyMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *string
	line_token    *string
	fb_token      *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notify, error)
	predicates    []predicate.Notify
}

var _ ent.Mutation = (*NotifyMutation)(nil)

// notifyOption allows management of the mutation configuration using functional options.
type notifyOption func(*NotifyMutation)

// newNotifyMutation creates new mutation for the Notify entity.
func newNotifyMutation(c config, op Op, opts ...notifyOption) *NotifyMutation {
	m := &NotifyMutation{
		config:        c,
		op:            op,
		typ:           TypeNotify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyID sets the ID field of the mutation.
func withNotifyID(id string) notifyOption {
	return func(m *NotifyMutation) {
		var (
			err   error
			once  sync.Once
			value *Notify
		)
		m.oldValue = func(ctx context.Context) (*Notify, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotify sets the old Notify of the mutation.
func withNotify(node *Notify) notifyOption {
	return func(m *NotifyMutation) {
		m.oldValue = func(context.Context) (*Notify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notify entities.
func (m *NotifyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notify.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *NotifyMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotifyMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotifyMutation) ResetUserID() {
	m.user_id = nil
}

// SetLineToken sets the "line_token" field.
func (m *NotifyMutation) SetLineToken(s string) {
	m.line_token = &s
}

// LineToken returns the value of the "line_token" field in the mutation.
func (m *NotifyMutation) LineToken() (r string, exists bool) {
	v := m.line_token
	if v == nil {
		return
	}
	return *v, true
}

// OldLineToken returns the old "line_token" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldLineToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineToken: %w", err)
	}
	return oldValue.LineToken, nil
}

// ResetLineToken resets all changes to the "line_token" field.
func (m *NotifyMutation) ResetLineToken() {
	m.line_token = nil
}

// SetFbToken sets the "fb_token" field.
func (m *NotifyMutation) SetFbToken(s string) {
	m.fb_token = &s
}

// FbToken returns the value of the "fb_token" field in the mutation.
func (m *NotifyMutation) FbToken() (r string, exists bool) {
	v := m.fb_token
	if v == nil {
		return
	}
	return *v, true
}

// OldFbToken returns the old "fb_token" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldFbToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFbToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFbToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFbToken: %w", err)
	}
	return oldValue.FbToken, nil
}

// ResetFbToken resets all changes to the "fb_token" field.
func (m *NotifyMutation) ResetFbToken() {
	m.fb_token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotifyMutation builder.
func (m *NotifyMutation) Where(ps ...predicate.Notify) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notify, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notify).
func (m *NotifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, notify.FieldUserID)
	}
	if m.line_token != nil {
		fields = append(fields, notify.FieldLineToken)
	}
	if m.fb_token != nil {
		fields = append(fields, notify.FieldFbToken)
	}
	if m.created_at != nil {
		fields = append(fields, notify.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notify.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notify.FieldUserID:
		return m.UserID()
	case notify.FieldLineToken:
		return m.LineToken()
	case notify.FieldFbToken:
		return m.FbToken()
	case notify.FieldCreatedAt:
		return m.CreatedAt()
	case notify.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notify.FieldUserID:
		return m.OldUserID(ctx)
	case notify.FieldLineToken:
		return m.OldLineToken(ctx)
	case notify.FieldFbToken:
		return m.OldFbToken(ctx)
	case notify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notify.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notify.FieldLineToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineToken(v)
		return nil
	case notify.FieldFbToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFbToken(v)
		return nil
	case notify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyMutation) ResetField(name string) error {
	switch name {
	case notify.FieldUserID:
		m.ResetUserID()
		return nil
	case notify.FieldLineToken:
		m.ResetLineToken()
		return nil
	case notify.FieldFbToken:
		m.ResetFbToken()
		return nil
	case notify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notify edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	order_num              *int
	addorder_num           *int
	comment                *string
	seller_comment         *string
	has_name               *bool
	is_extra               *bool
	fb                     *bool
	is_in_stock            *bool
	status                 *order.Status
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *string
	cleareduser            bool
	post                   *string
	clearedpost            bool
	order_items            map[string]struct{}
	removedorder_items     map[string]struct{}
	clearedorder_items     bool
	order_histories        map[string]struct{}
	removedorder_histories map[string]struct{}
	clearedorder_histories bool
	done                   bool
	oldValue               func(context.Context) (*Order, error)
	predicates             []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id string) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *OrderMutation) SetPostID(s string) {
	m.post = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *OrderMutation) PostID() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *OrderMutation) ResetPostID() {
	m.post = nil
}

// SetOrderNum sets the "order_num" field.
func (m *OrderMutation) SetOrderNum(i int) {
	m.order_num = &i
	m.addorder_num = nil
}

// OrderNum returns the value of the "order_num" field in the mutation.
func (m *OrderMutation) OrderNum() (r int, exists bool) {
	v := m.order_num
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNum returns the old "order_num" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNum(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNum: %w", err)
	}
	return oldValue.OrderNum, nil
}

// AddOrderNum adds i to the "order_num" field.
func (m *OrderMutation) AddOrderNum(i int) {
	if m.addorder_num != nil {
		*m.addorder_num += i
	} else {
		m.addorder_num = &i
	}
}

// AddedOrderNum returns the value that was added to the "order_num" field in this mutation.
func (m *OrderMutation) AddedOrderNum() (r int, exists bool) {
	v := m.addorder_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNum resets all changes to the "order_num" field.
func (m *OrderMutation) ResetOrderNum() {
	m.order_num = nil
	m.addorder_num = nil
}

// SetComment sets the "comment" field.
func (m *OrderMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *OrderMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *OrderMutation) ResetComment() {
	m.comment = nil
}

// SetSellerComment sets the "seller_comment" field.
func (m *OrderMutation) SetSellerComment(s string) {
	m.seller_comment = &s
}

// SellerComment returns the value of the "seller_comment" field in the mutation.
func (m *OrderMutation) SellerComment() (r string, exists bool) {
	v := m.seller_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldSellerComment returns the old "seller_comment" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSellerComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellerComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellerComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellerComment: %w", err)
	}
	return oldValue.SellerComment, nil
}

// ResetSellerComment resets all changes to the "seller_comment" field.
func (m *OrderMutation) ResetSellerComment() {
	m.seller_comment = nil
}

// SetHasName sets the "has_name" field.
func (m *OrderMutation) SetHasName(b bool) {
	m.has_name = &b
}

// HasName returns the value of the "has_name" field in the mutation.
func (m *OrderMutation) HasName() (r bool, exists bool) {
	v := m.has_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHasName returns the old "has_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldHasName(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasName: %w", err)
	}
	return oldValue.HasName, nil
}

// ResetHasName resets all changes to the "has_name" field.
func (m *OrderMutation) ResetHasName() {
	m.has_name = nil
}

// SetIsExtra sets the "is_extra" field.
func (m *OrderMutation) SetIsExtra(b bool) {
	m.is_extra = &b
}

// IsExtra returns the value of the "is_extra" field in the mutation.
func (m *OrderMutation) IsExtra() (r bool, exists bool) {
	v := m.is_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExtra returns the old "is_extra" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsExtra(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExtra: %w", err)
	}
	return oldValue.IsExtra, nil
}

// ResetIsExtra resets all changes to the "is_extra" field.
func (m *OrderMutation) ResetIsExtra() {
	m.is_extra = nil
}

// SetFb sets the "fb" field.
func (m *OrderMutation) SetFb(b bool) {
	m.fb = &b
}

// Fb returns the value of the "fb" field in the mutation.
func (m *OrderMutation) Fb() (r bool, exists bool) {
	v := m.fb
	if v == nil {
		return
	}
	return *v, true
}

// OldFb returns the old "fb" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFb(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFb: %w", err)
	}
	return oldValue.Fb, nil
}

// ResetFb resets all changes to the "fb" field.
func (m *OrderMutation) ResetFb() {
	m.fb = nil
}

// SetIsInStock sets the "is_in_stock" field.
func (m *OrderMutation) SetIsInStock(b bool) {
	m.is_in_stock = &b
}

// IsInStock returns the value of the "is_in_stock" field in the mutation.
func (m *OrderMutation) IsInStock() (r bool, exists bool) {
	v := m.is_in_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInStock returns the old "is_in_stock" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsInStock(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInStock: %w", err)
	}
	return oldValue.IsInStock, nil
}

// ResetIsInStock resets all changes to the "is_in_stock" field.
func (m *OrderMutation) ResetIsInStock() {
	m.is_in_stock = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v *order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *OrderMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[order.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *OrderMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *OrderMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...string) {
	if m.order_items == nil {
		m.order_items = make(map[string]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...string) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []string) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []string) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddOrderHistoryIDs adds the "order_histories" edge to the OrderHistory entity by ids.
func (m *OrderMutation) AddOrderHistoryIDs(ids ...string) {
	if m.order_histories == nil {
		m.order_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.order_histories[ids[i]] = struct{}{}
	}
}

// ClearOrderHistories clears the "order_histories" edge to the OrderHistory entity.
func (m *OrderMutation) ClearOrderHistories() {
	m.clearedorder_histories = true
}

// OrderHistoriesCleared reports if the "order_histories" edge to the OrderHistory entity was cleared.
func (m *OrderMutation) OrderHistoriesCleared() bool {
	return m.clearedorder_histories
}

// RemoveOrderHistoryIDs removes the "order_histories" edge to the OrderHistory entity by IDs.
func (m *OrderMutation) RemoveOrderHistoryIDs(ids ...string) {
	if m.removedorder_histories == nil {
		m.removedorder_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_histories, ids[i])
		m.removedorder_histories[ids[i]] = struct{}{}
	}
}

// RemovedOrderHistories returns the removed IDs of the "order_histories" edge to the OrderHistory entity.
func (m *OrderMutation) RemovedOrderHistoriesIDs() (ids []string) {
	for id := range m.removedorder_histories {
		ids = append(ids, id)
	}
	return
}

// OrderHistoriesIDs returns the "order_histories" edge IDs in the mutation.
func (m *OrderMutation) OrderHistoriesIDs() (ids []string) {
	for id := range m.order_histories {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHistories resets all changes to the "order_histories" edge.
func (m *OrderMutation) ResetOrderHistories() {
	m.order_histories = nil
	m.clearedorder_histories = false
	m.removedorder_histories = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.post != nil {
		fields = append(fields, order.FieldPostID)
	}
	if m.order_num != nil {
		fields = append(fields, order.FieldOrderNum)
	}
	if m.comment != nil {
		fields = append(fields, order.FieldComment)
	}
	if m.seller_comment != nil {
		fields = append(fields, order.FieldSellerComment)
	}
	if m.has_name != nil {
		fields = append(fields, order.FieldHasName)
	}
	if m.is_extra != nil {
		fields = append(fields, order.FieldIsExtra)
	}
	if m.fb != nil {
		fields = append(fields, order.FieldFb)
	}
	if m.is_in_stock != nil {
		fields = append(fields, order.FieldIsInStock)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldUserID:
		return m.UserID()
	case order.FieldPostID:
		return m.PostID()
	case order.FieldOrderNum:
		return m.OrderNum()
	case order.FieldComment:
		return m.Comment()
	case order.FieldSellerComment:
		return m.SellerComment()
	case order.FieldHasName:
		return m.HasName()
	case order.FieldIsExtra:
		return m.IsExtra()
	case order.FieldFb:
		return m.Fb()
	case order.FieldIsInStock:
		return m.IsInStock()
	case order.FieldStatus:
		return m.Status()
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldPostID:
		return m.OldPostID(ctx)
	case order.FieldOrderNum:
		return m.OldOrderNum(ctx)
	case order.FieldComment:
		return m.OldComment(ctx)
	case order.FieldSellerComment:
		return m.OldSellerComment(ctx)
	case order.FieldHasName:
		return m.OldHasName(ctx)
	case order.FieldIsExtra:
		return m.OldIsExtra(ctx)
	case order.FieldFb:
		return m.OldFb(ctx)
	case order.FieldIsInStock:
		return m.OldIsInStock(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case order.FieldOrderNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNum(v)
		return nil
	case order.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case order.FieldSellerComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellerComment(v)
		return nil
	case order.FieldHasName:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasName(v)
		return nil
	case order.FieldIsExtra:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExtra(v)
		return nil
	case order.FieldFb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFb(v)
		return nil
	case order.FieldIsInStock:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInStock(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addorder_num != nil {
		fields = append(fields, order.FieldOrderNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldOrderNum:
		return m.AddedOrderNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldOrderNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNum(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldPostID:
		m.ResetPostID()
		return nil
	case order.FieldOrderNum:
		m.ResetOrderNum()
		return nil
	case order.FieldComment:
		m.ResetComment()
		return nil
	case order.FieldSellerComment:
		m.ResetSellerComment()
		return nil
	case order.FieldHasName:
		m.ResetHasName()
		return nil
	case order.FieldIsExtra:
		m.ResetIsExtra()
		return nil
	case order.FieldFb:
		m.ResetFb()
		return nil
	case order.FieldIsInStock:
		m.ResetIsInStock()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, order.EdgePost)
	}
	if m.order_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.order_histories != nil {
		edges = append(edges, order.EdgeOrderHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.order_histories))
		for id := range m.order_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorder_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.removedorder_histories != nil {
		edges = append(edges, order.EdgeOrderHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.removedorder_histories))
		for id := range m.removedorder_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, order.EdgePost)
	}
	if m.clearedorder_items {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.clearedorder_histories {
		edges = append(edges, order.EdgeOrderHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgePost:
		return m.clearedpost
	case order.EdgeOrderItems:
		return m.clearedorder_items
	case order.EdgeOrderHistories:
		return m.clearedorder_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	case order.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgePost:
		m.ResetPost()
		return nil
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case order.EdgeOrderHistories:
		m.ResetOrderHistories()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderHistoryMutation represents an operation that mutates the OrderHistory nodes in the graph.
type OrderHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	status        *orderhistory.Status
	created_at    *time.Time
	clearedFields map[string]struct{}
	_order        *string
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderHistory, error)
	predicates    []predicate.OrderHistory
}

var _ ent.Mutation = (*OrderHistoryMutation)(nil)

// orderhistoryOption allows management of the mutation configuration using functional options.
type orderhistoryOption func(*OrderHistoryMutation)

// newOrderHistoryMutation creates new mutation for the OrderHistory entity.
func newOrderHistoryMutation(c config, op Op, opts ...orderhistoryOption) *OrderHistoryMutation {
	m := &OrderHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderHistoryID sets the ID field of the mutation.
func withOrderHistoryID(id string) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderHistory
		)
		m.oldValue = func(ctx context.Context) (*OrderHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderHistory sets the old OrderHistory of the mutation.
func withOrderHistory(node *OrderHistory) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		m.oldValue = func(context.Context) (*OrderHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderHistory entities.
func (m *OrderHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderHistoryMutation) SetOrderID(s string) {
	m._order = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderHistoryMutation) OrderID() (r string, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderHistoryMutation) ResetOrderID() {
	m._order = nil
}

// SetStatus sets the "status" field.
func (m *OrderHistoryMutation) SetStatus(o orderhistory.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderHistoryMutation) Status() (r orderhistory.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldStatus(ctx context.Context) (v *orderhistory.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderHistoryMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderhistory.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderHistoryMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) OrderIDs() (ids []string) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderHistoryMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderHistoryMutation builder.
func (m *OrderHistoryMutation) Where(ps ...predicate.OrderHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderHistory).
func (m *OrderHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._order != nil {
		fields = append(fields, orderhistory.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, orderhistory.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, orderhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderhistory.FieldOrderID:
		return m.OrderID()
	case orderhistory.FieldStatus:
		return m.Status()
	case orderhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderhistory.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderhistory.FieldStatus:
		return m.OldStatus(ctx)
	case orderhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderhistory.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderhistory.FieldStatus:
		v, ok := value.(orderhistory.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ResetField(name string) error {
	switch name {
	case orderhistory.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case orderhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderhistory.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderhistory.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderhistory.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case orderhistory.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderHistoryMutation) ClearEdge(name string) error {
	switch name {
	case orderhistory.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderHistoryMutation) ResetEdge(name string) error {
	switch name {
	case orderhistory.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op               Op
	typ              string
	id               *string
	identifier       *string
	name             *string
	price            *float64
	addprice         *float64
	qty              *float64
	addqty           *float64
	location         *string
	has_name         *bool
	status           *orderitem.Status
	clearedFields    map[string]struct{}
	_order           *string
	cleared_order    bool
	post_item        *string
	clearedpost_item bool
	done             bool
	oldValue         func(context.Context) (*OrderItem, error)
	predicates       []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id string) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(s string) {
	m._order = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r string, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
}

// SetPostItemID sets the "post_item_id" field.
func (m *OrderItemMutation) SetPostItemID(s string) {
	m.post_item = &s
}

// PostItemID returns the value of the "post_item_id" field in the mutation.
func (m *OrderItemMutation) PostItemID() (r string, exists bool) {
	v := m.post_item
	if v == nil {
		return
	}
	return *v, true
}

// OldPostItemID returns the old "post_item_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPostItemID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostItemID: %w", err)
	}
	return oldValue.PostItemID, nil
}

// ResetPostItemID resets all changes to the "post_item_id" field.
func (m *OrderItemMutation) ResetPostItemID() {
	m.post_item = nil
}

// SetIdentifier sets the "identifier" field.
func (m *OrderItemMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *OrderItemMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldIdentifier(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *OrderItemMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *OrderItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *OrderItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetQty sets the "qty" field.
func (m *OrderItemMutation) SetQty(f float64) {
	m.qty = &f
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *OrderItemMutation) Qty() (r float64, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQty(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds f to the "qty" field.
func (m *OrderItemMutation) AddQty(f float64) {
	if m.addqty != nil {
		*m.addqty += f
	} else {
		m.addqty = &f
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *OrderItemMutation) AddedQty() (r float64, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *OrderItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetLocation sets the "location" field.
func (m *OrderItemMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *OrderItemMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *OrderItemMutation) ResetLocation() {
	m.location = nil
}

// SetHasName sets the "has_name" field.
func (m *OrderItemMutation) SetHasName(b bool) {
	m.has_name = &b
}

// HasName returns the value of the "has_name" field in the mutation.
func (m *OrderItemMutation) HasName() (r bool, exists bool) {
	v := m.has_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHasName returns the old "has_name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldHasName(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasName: %w", err)
	}
	return oldValue.HasName, nil
}

// ResetHasName resets all changes to the "has_name" field.
func (m *OrderItemMutation) ResetHasName() {
	m.has_name = nil
}

// SetStatus sets the "status" field.
func (m *OrderItemMutation) SetStatus(o orderitem.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderItemMutation) Status() (r orderitem.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldStatus(ctx context.Context) (v *orderitem.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderItemMutation) ResetStatus() {
	m.status = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []string) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearPostItem clears the "post_item" edge to the PostItem entity.
func (m *OrderItemMutation) ClearPostItem() {
	m.clearedpost_item = true
	m.clearedFields[orderitem.FieldPostItemID] = struct{}{}
}

// PostItemCleared reports if the "post_item" edge to the PostItem entity was cleared.
func (m *OrderItemMutation) PostItemCleared() bool {
	return m.clearedpost_item
}

// PostItemIDs returns the "post_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) PostItemIDs() (ids []string) {
	if id := m.post_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostItem resets all changes to the "post_item" edge.
func (m *OrderItemMutation) ResetPostItem() {
	m.post_item = nil
	m.clearedpost_item = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.post_item != nil {
		fields = append(fields, orderitem.FieldPostItemID)
	}
	if m.identifier != nil {
		fields = append(fields, orderitem.FieldIdentifier)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m.price != nil {
		fields = append(fields, orderitem.FieldPrice)
	}
	if m.qty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	if m.location != nil {
		fields = append(fields, orderitem.FieldLocation)
	}
	if m.has_name != nil {
		fields = append(fields, orderitem.FieldHasName)
	}
	if m.status != nil {
		fields = append(fields, orderitem.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldPostItemID:
		return m.PostItemID()
	case orderitem.FieldIdentifier:
		return m.Identifier()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldPrice:
		return m.Price()
	case orderitem.FieldQty:
		return m.Qty()
	case orderitem.FieldLocation:
		return m.Location()
	case orderitem.FieldHasName:
		return m.HasName()
	case orderitem.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldPostItemID:
		return m.OldPostItemID(ctx)
	case orderitem.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldPrice:
		return m.OldPrice(ctx)
	case orderitem.FieldQty:
		return m.OldQty(ctx)
	case orderitem.FieldLocation:
		return m.OldLocation(ctx)
	case orderitem.FieldHasName:
		return m.OldHasName(ctx)
	case orderitem.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldPostItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostItemID(v)
		return nil
	case orderitem.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderitem.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case orderitem.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case orderitem.FieldHasName:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasName(v)
		return nil
	case orderitem.FieldStatus:
		v, ok := value.(orderitem.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, orderitem.FieldPrice)
	}
	if m.addqty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldPrice:
		return m.AddedPrice()
	case orderitem.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case orderitem.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldPostItemID:
		m.ResetPostItemID()
		return nil
	case orderitem.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldPrice:
		m.ResetPrice()
		return nil
	case orderitem.FieldQty:
		m.ResetQty()
		return nil
	case orderitem.FieldLocation:
		m.ResetLocation()
		return nil
	case orderitem.FieldHasName:
		m.ResetHasName()
		return nil
	case orderitem.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.post_item != nil {
		edges = append(edges, orderitem.EdgePostItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgePostItem:
		if id := m.post_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedpost_item {
		edges = append(edges, orderitem.EdgePostItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgePostItem:
		return m.clearedpost_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderitem.EdgePostItem:
		m.ClearPostItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgePostItem:
		m.ResetPostItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	post_num             *int
	addpost_num          *int
	title                *string
	body                 *string
	deadline             *string
	delivery_date        *string
	like_count           *int
	addlike_count        *int
	comment_count        *int
	addcomment_count     *int
	order_count          *int
	addorder_count       *int
	images               *[]schema.Image
	appendimages         []schema.Image
	storage_type         *post.StorageType
	status               *post.Status
	comment              *string
	delivered            *bool
	is_in_stock          *bool
	normal_total         *float64
	addnormal_total      *float64
	normal_fee           *float64
	addnormal_fee        *float64
	extra_total          *float64
	addextra_total       *float64
	extra_fee            *float64
	addextra_fee         *float64
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	seller               *string
	clearedseller        bool
	post_comments        map[string]struct{}
	removedpost_comments map[string]struct{}
	clearedpost_comments bool
	post_delivers        map[string]struct{}
	removedpost_delivers map[string]struct{}
	clearedpost_delivers bool
	post_items           map[string]struct{}
	removedpost_items    map[string]struct{}
	clearedpost_items    bool
	post_likes           map[string]struct{}
	removedpost_likes    map[string]struct{}
	clearedpost_likes    bool
	post_orders          map[string]struct{}
	removedpost_orders   map[string]struct{}
	clearedpost_orders   bool
	done                 bool
	oldValue             func(context.Context) (*Post, error)
	predicates           []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSellerID sets the "seller_id" field.
func (m *PostMutation) SetSellerID(s string) {
	m.seller = &s
}

// SellerID returns the value of the "seller_id" field in the mutation.
func (m *PostMutation) SellerID() (r string, exists bool) {
	v := m.seller
	if v == nil {
		return
	}
	return *v, true
}

// OldSellerID returns the old "seller_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSellerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellerID: %w", err)
	}
	return oldValue.SellerID, nil
}

// ResetSellerID resets all changes to the "seller_id" field.
func (m *PostMutation) ResetSellerID() {
	m.seller = nil
}

// SetPostNum sets the "post_num" field.
func (m *PostMutation) SetPostNum(i int) {
	m.post_num = &i
	m.addpost_num = nil
}

// PostNum returns the value of the "post_num" field in the mutation.
func (m *PostMutation) PostNum() (r int, exists bool) {
	v := m.post_num
	if v == nil {
		return
	}
	return *v, true
}

// OldPostNum returns the old "post_num" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPostNum(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostNum: %w", err)
	}
	return oldValue.PostNum, nil
}

// AddPostNum adds i to the "post_num" field.
func (m *PostMutation) AddPostNum(i int) {
	if m.addpost_num != nil {
		*m.addpost_num += i
	} else {
		m.addpost_num = &i
	}
}

// AddedPostNum returns the value that was added to the "post_num" field in this mutation.
func (m *PostMutation) AddedPostNum() (r int, exists bool) {
	v := m.addpost_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostNum resets all changes to the "post_num" field.
func (m *PostMutation) ResetPostNum() {
	m.post_num = nil
	m.addpost_num = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *PostMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PostMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PostMutation) ResetBody() {
	m.body = nil
}

// SetDeadline sets the "deadline" field.
func (m *PostMutation) SetDeadline(s string) {
	m.deadline = &s
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *PostMutation) Deadline() (r string, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeadline(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *PostMutation) ResetDeadline() {
	m.deadline = nil
}

// SetDeliveryDate sets the "delivery_date" field.
func (m *PostMutation) SetDeliveryDate(s string) {
	m.delivery_date = &s
}

// DeliveryDate returns the value of the "delivery_date" field in the mutation.
func (m *PostMutation) DeliveryDate() (r string, exists bool) {
	v := m.delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryDate returns the old "delivery_date" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeliveryDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryDate: %w", err)
	}
	return oldValue.DeliveryDate, nil
}

// ResetDeliveryDate resets all changes to the "delivery_date" field.
func (m *PostMutation) ResetDeliveryDate() {
	m.delivery_date = nil
}

// SetLikeCount sets the "like_count" field.
func (m *PostMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *PostMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikeCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *PostMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *PostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *PostMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *PostMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *PostMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCommentCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *PostMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *PostMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *PostMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetOrderCount sets the "order_count" field.
func (m *PostMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *PostMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldOrderCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *PostMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *PostMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *PostMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
}

// SetImages sets the "images" field.
func (m *PostMutation) SetImages(s []schema.Image) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *PostMutation) Images() (r []schema.Image, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldImages(ctx context.Context) (v []schema.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *PostMutation) AppendImages(s []schema.Image) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *PostMutation) AppendedImages() ([]schema.Image, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ResetImages resets all changes to the "images" field.
func (m *PostMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
}

// SetStorageType sets the "storage_type" field.
func (m *PostMutation) SetStorageType(pt post.StorageType) {
	m.storage_type = &pt
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *PostMutation) StorageType() (r post.StorageType, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStorageType(ctx context.Context) (v *post.StorageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *PostMutation) ResetStorageType() {
	m.storage_type = nil
}

// SetStatus sets the "status" field.
func (m *PostMutation) SetStatus(po post.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PostMutation) Status() (r post.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStatus(ctx context.Context) (v *post.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PostMutation) ResetStatus() {
	m.status = nil
}

// SetComment sets the "comment" field.
func (m *PostMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *PostMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *PostMutation) ResetComment() {
	m.comment = nil
}

// SetDelivered sets the "delivered" field.
func (m *PostMutation) SetDelivered(b bool) {
	m.delivered = &b
}

// Delivered returns the value of the "delivered" field in the mutation.
func (m *PostMutation) Delivered() (r bool, exists bool) {
	v := m.delivered
	if v == nil {
		return
	}
	return *v, true
}

// OldDelivered returns the old "delivered" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDelivered(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelivered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelivered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelivered: %w", err)
	}
	return oldValue.Delivered, nil
}

// ResetDelivered resets all changes to the "delivered" field.
func (m *PostMutation) ResetDelivered() {
	m.delivered = nil
}

// SetIsInStock sets the "is_in_stock" field.
func (m *PostMutation) SetIsInStock(b bool) {
	m.is_in_stock = &b
}

// IsInStock returns the value of the "is_in_stock" field in the mutation.
func (m *PostMutation) IsInStock() (r bool, exists bool) {
	v := m.is_in_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInStock returns the old "is_in_stock" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsInStock(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInStock: %w", err)
	}
	return oldValue.IsInStock, nil
}

// ResetIsInStock resets all changes to the "is_in_stock" field.
func (m *PostMutation) ResetIsInStock() {
	m.is_in_stock = nil
}

// SetNormalTotal sets the "normal_total" field.
func (m *PostMutation) SetNormalTotal(f float64) {
	m.normal_total = &f
	m.addnormal_total = nil
}

// NormalTotal returns the value of the "normal_total" field in the mutation.
func (m *PostMutation) NormalTotal() (r float64, exists bool) {
	v := m.normal_total
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTotal returns the old "normal_total" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldNormalTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTotal: %w", err)
	}
	return oldValue.NormalTotal, nil
}

// AddNormalTotal adds f to the "normal_total" field.
func (m *PostMutation) AddNormalTotal(f float64) {
	if m.addnormal_total != nil {
		*m.addnormal_total += f
	} else {
		m.addnormal_total = &f
	}
}

// AddedNormalTotal returns the value that was added to the "normal_total" field in this mutation.
func (m *PostMutation) AddedNormalTotal() (r float64, exists bool) {
	v := m.addnormal_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTotal resets all changes to the "normal_total" field.
func (m *PostMutation) ResetNormalTotal() {
	m.normal_total = nil
	m.addnormal_total = nil
}

// SetNormalFee sets the "normal_fee" field.
func (m *PostMutation) SetNormalFee(f float64) {
	m.normal_fee = &f
	m.addnormal_fee = nil
}

// NormalFee returns the value of the "normal_fee" field in the mutation.
func (m *PostMutation) NormalFee() (r float64, exists bool) {
	v := m.normal_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalFee returns the old "normal_fee" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldNormalFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalFee: %w", err)
	}
	return oldValue.NormalFee, nil
}

// AddNormalFee adds f to the "normal_fee" field.
func (m *PostMutation) AddNormalFee(f float64) {
	if m.addnormal_fee != nil {
		*m.addnormal_fee += f
	} else {
		m.addnormal_fee = &f
	}
}

// AddedNormalFee returns the value that was added to the "normal_fee" field in this mutation.
func (m *PostMutation) AddedNormalFee() (r float64, exists bool) {
	v := m.addnormal_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalFee resets all changes to the "normal_fee" field.
func (m *PostMutation) ResetNormalFee() {
	m.normal_fee = nil
	m.addnormal_fee = nil
}

// SetExtraTotal sets the "extra_total" field.
func (m *PostMutation) SetExtraTotal(f float64) {
	m.extra_total = &f
	m.addextra_total = nil
}

// ExtraTotal returns the value of the "extra_total" field in the mutation.
func (m *PostMutation) ExtraTotal() (r float64, exists bool) {
	v := m.extra_total
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraTotal returns the old "extra_total" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldExtraTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraTotal: %w", err)
	}
	return oldValue.ExtraTotal, nil
}

// AddExtraTotal adds f to the "extra_total" field.
func (m *PostMutation) AddExtraTotal(f float64) {
	if m.addextra_total != nil {
		*m.addextra_total += f
	} else {
		m.addextra_total = &f
	}
}

// AddedExtraTotal returns the value that was added to the "extra_total" field in this mutation.
func (m *PostMutation) AddedExtraTotal() (r float64, exists bool) {
	v := m.addextra_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtraTotal resets all changes to the "extra_total" field.
func (m *PostMutation) ResetExtraTotal() {
	m.extra_total = nil
	m.addextra_total = nil
}

// SetExtraFee sets the "extra_fee" field.
func (m *PostMutation) SetExtraFee(f float64) {
	m.extra_fee = &f
	m.addextra_fee = nil
}

// ExtraFee returns the value of the "extra_fee" field in the mutation.
func (m *PostMutation) ExtraFee() (r float64, exists bool) {
	v := m.extra_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraFee returns the old "extra_fee" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldExtraFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraFee: %w", err)
	}
	return oldValue.ExtraFee, nil
}

// AddExtraFee adds f to the "extra_fee" field.
func (m *PostMutation) AddExtraFee(f float64) {
	if m.addextra_fee != nil {
		*m.addextra_fee += f
	} else {
		m.addextra_fee = &f
	}
}

// AddedExtraFee returns the value that was added to the "extra_fee" field in this mutation.
func (m *PostMutation) AddedExtraFee() (r float64, exists bool) {
	v := m.addextra_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtraFee resets all changes to the "extra_fee" field.
func (m *PostMutation) ResetExtraFee() {
	m.extra_fee = nil
	m.addextra_fee = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearSeller clears the "seller" edge to the User entity.
func (m *PostMutation) ClearSeller() {
	m.clearedseller = true
	m.clearedFields[post.FieldSellerID] = struct{}{}
}

// SellerCleared reports if the "seller" edge to the User entity was cleared.
func (m *PostMutation) SellerCleared() bool {
	return m.clearedseller
}

// SellerIDs returns the "seller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerID instead. It exists only for internal usage by the builders.
func (m *PostMutation) SellerIDs() (ids []string) {
	if id := m.seller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeller resets all changes to the "seller" edge.
func (m *PostMutation) ResetSeller() {
	m.seller = nil
	m.clearedseller = false
}

// AddPostCommentIDs adds the "post_comments" edge to the Comment entity by ids.
func (m *PostMutation) AddPostCommentIDs(ids ...string) {
	if m.post_comments == nil {
		m.post_comments = make(map[string]struct{})
	}
	for i := range ids {
		m.post_comments[ids[i]] = struct{}{}
	}
}

// ClearPostComments clears the "post_comments" edge to the Comment entity.
func (m *PostMutation) ClearPostComments() {
	m.clearedpost_comments = true
}

// PostCommentsCleared reports if the "post_comments" edge to the Comment entity was cleared.
func (m *PostMutation) PostCommentsCleared() bool {
	return m.clearedpost_comments
}

// RemovePostCommentIDs removes the "post_comments" edge to the Comment entity by IDs.
func (m *PostMutation) RemovePostCommentIDs(ids ...string) {
	if m.removedpost_comments == nil {
		m.removedpost_comments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_comments, ids[i])
		m.removedpost_comments[ids[i]] = struct{}{}
	}
}

// RemovedPostComments returns the removed IDs of the "post_comments" edge to the Comment entity.
func (m *PostMutation) RemovedPostCommentsIDs() (ids []string) {
	for id := range m.removedpost_comments {
		ids = append(ids, id)
	}
	return
}

// PostCommentsIDs returns the "post_comments" edge IDs in the mutation.
func (m *PostMutation) PostCommentsIDs() (ids []string) {
	for id := range m.post_comments {
		ids = append(ids, id)
	}
	return
}

// ResetPostComments resets all changes to the "post_comments" edge.
func (m *PostMutation) ResetPostComments() {
	m.post_comments = nil
	m.clearedpost_comments = false
	m.removedpost_comments = nil
}

// AddPostDeliverIDs adds the "post_delivers" edge to the Deliver entity by ids.
func (m *PostMutation) AddPostDeliverIDs(ids ...string) {
	if m.post_delivers == nil {
		m.post_delivers = make(map[string]struct{})
	}
	for i := range ids {
		m.post_delivers[ids[i]] = struct{}{}
	}
}

// ClearPostDelivers clears the "post_delivers" edge to the Deliver entity.
func (m *PostMutation) ClearPostDelivers() {
	m.clearedpost_delivers = true
}

// PostDeliversCleared reports if the "post_delivers" edge to the Deliver entity was cleared.
func (m *PostMutation) PostDeliversCleared() bool {
	return m.clearedpost_delivers
}

// RemovePostDeliverIDs removes the "post_delivers" edge to the Deliver entity by IDs.
func (m *PostMutation) RemovePostDeliverIDs(ids ...string) {
	if m.removedpost_delivers == nil {
		m.removedpost_delivers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_delivers, ids[i])
		m.removedpost_delivers[ids[i]] = struct{}{}
	}
}

// RemovedPostDelivers returns the removed IDs of the "post_delivers" edge to the Deliver entity.
func (m *PostMutation) RemovedPostDeliversIDs() (ids []string) {
	for id := range m.removedpost_delivers {
		ids = append(ids, id)
	}
	return
}

// PostDeliversIDs returns the "post_delivers" edge IDs in the mutation.
func (m *PostMutation) PostDeliversIDs() (ids []string) {
	for id := range m.post_delivers {
		ids = append(ids, id)
	}
	return
}

// ResetPostDelivers resets all changes to the "post_delivers" edge.
func (m *PostMutation) ResetPostDelivers() {
	m.post_delivers = nil
	m.clearedpost_delivers = false
	m.removedpost_delivers = nil
}

// AddPostItemIDs adds the "post_items" edge to the PostItem entity by ids.
func (m *PostMutation) AddPostItemIDs(ids ...string) {
	if m.post_items == nil {
		m.post_items = make(map[string]struct{})
	}
	for i := range ids {
		m.post_items[ids[i]] = struct{}{}
	}
}

// ClearPostItems clears the "post_items" edge to the PostItem entity.
func (m *PostMutation) ClearPostItems() {
	m.clearedpost_items = true
}

// PostItemsCleared reports if the "post_items" edge to the PostItem entity was cleared.
func (m *PostMutation) PostItemsCleared() bool {
	return m.clearedpost_items
}

// RemovePostItemIDs removes the "post_items" edge to the PostItem entity by IDs.
func (m *PostMutation) RemovePostItemIDs(ids ...string) {
	if m.removedpost_items == nil {
		m.removedpost_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_items, ids[i])
		m.removedpost_items[ids[i]] = struct{}{}
	}
}

// RemovedPostItems returns the removed IDs of the "post_items" edge to the PostItem entity.
func (m *PostMutation) RemovedPostItemsIDs() (ids []string) {
	for id := range m.removedpost_items {
		ids = append(ids, id)
	}
	return
}

// PostItemsIDs returns the "post_items" edge IDs in the mutation.
func (m *PostMutation) PostItemsIDs() (ids []string) {
	for id := range m.post_items {
		ids = append(ids, id)
	}
	return
}

// ResetPostItems resets all changes to the "post_items" edge.
func (m *PostMutation) ResetPostItems() {
	m.post_items = nil
	m.clearedpost_items = false
	m.removedpost_items = nil
}

// AddPostLikeIDs adds the "post_likes" edge to the Like entity by ids.
func (m *PostMutation) AddPostLikeIDs(ids ...string) {
	if m.post_likes == nil {
		m.post_likes = make(map[string]struct{})
	}
	for i := range ids {
		m.post_likes[ids[i]] = struct{}{}
	}
}

// ClearPostLikes clears the "post_likes" edge to the Like entity.
func (m *PostMutation) ClearPostLikes() {
	m.clearedpost_likes = true
}

// PostLikesCleared reports if the "post_likes" edge to the Like entity was cleared.
func (m *PostMutation) PostLikesCleared() bool {
	return m.clearedpost_likes
}

// RemovePostLikeIDs removes the "post_likes" edge to the Like entity by IDs.
func (m *PostMutation) RemovePostLikeIDs(ids ...string) {
	if m.removedpost_likes == nil {
		m.removedpost_likes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_likes, ids[i])
		m.removedpost_likes[ids[i]] = struct{}{}
	}
}

// RemovedPostLikes returns the removed IDs of the "post_likes" edge to the Like entity.
func (m *PostMutation) RemovedPostLikesIDs() (ids []string) {
	for id := range m.removedpost_likes {
		ids = append(ids, id)
	}
	return
}

// PostLikesIDs returns the "post_likes" edge IDs in the mutation.
func (m *PostMutation) PostLikesIDs() (ids []string) {
	for id := range m.post_likes {
		ids = append(ids, id)
	}
	return
}

// ResetPostLikes resets all changes to the "post_likes" edge.
func (m *PostMutation) ResetPostLikes() {
	m.post_likes = nil
	m.clearedpost_likes = false
	m.removedpost_likes = nil
}

// AddPostOrderIDs adds the "post_orders" edge to the Order entity by ids.
func (m *PostMutation) AddPostOrderIDs(ids ...string) {
	if m.post_orders == nil {
		m.post_orders = make(map[string]struct{})
	}
	for i := range ids {
		m.post_orders[ids[i]] = struct{}{}
	}
}

// ClearPostOrders clears the "post_orders" edge to the Order entity.
func (m *PostMutation) ClearPostOrders() {
	m.clearedpost_orders = true
}

// PostOrdersCleared reports if the "post_orders" edge to the Order entity was cleared.
func (m *PostMutation) PostOrdersCleared() bool {
	return m.clearedpost_orders
}

// RemovePostOrderIDs removes the "post_orders" edge to the Order entity by IDs.
func (m *PostMutation) RemovePostOrderIDs(ids ...string) {
	if m.removedpost_orders == nil {
		m.removedpost_orders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_orders, ids[i])
		m.removedpost_orders[ids[i]] = struct{}{}
	}
}

// RemovedPostOrders returns the removed IDs of the "post_orders" edge to the Order entity.
func (m *PostMutation) RemovedPostOrdersIDs() (ids []string) {
	for id := range m.removedpost_orders {
		ids = append(ids, id)
	}
	return
}

// PostOrdersIDs returns the "post_orders" edge IDs in the mutation.
func (m *PostMutation) PostOrdersIDs() (ids []string) {
	for id := range m.post_orders {
		ids = append(ids, id)
	}
	return
}

// ResetPostOrders resets all changes to the "post_orders" edge.
func (m *PostMutation) ResetPostOrders() {
	m.post_orders = nil
	m.clearedpost_orders = false
	m.removedpost_orders = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.seller != nil {
		fields = append(fields, post.FieldSellerID)
	}
	if m.post_num != nil {
		fields = append(fields, post.FieldPostNum)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, post.FieldBody)
	}
	if m.deadline != nil {
		fields = append(fields, post.FieldDeadline)
	}
	if m.delivery_date != nil {
		fields = append(fields, post.FieldDeliveryDate)
	}
	if m.like_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.comment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.order_count != nil {
		fields = append(fields, post.FieldOrderCount)
	}
	if m.images != nil {
		fields = append(fields, post.FieldImages)
	}
	if m.storage_type != nil {
		fields = append(fields, post.FieldStorageType)
	}
	if m.status != nil {
		fields = append(fields, post.FieldStatus)
	}
	if m.comment != nil {
		fields = append(fields, post.FieldComment)
	}
	if m.delivered != nil {
		fields = append(fields, post.FieldDelivered)
	}
	if m.is_in_stock != nil {
		fields = append(fields, post.FieldIsInStock)
	}
	if m.normal_total != nil {
		fields = append(fields, post.FieldNormalTotal)
	}
	if m.normal_fee != nil {
		fields = append(fields, post.FieldNormalFee)
	}
	if m.extra_total != nil {
		fields = append(fields, post.FieldExtraTotal)
	}
	if m.extra_fee != nil {
		fields = append(fields, post.FieldExtraFee)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldSellerID:
		return m.SellerID()
	case post.FieldPostNum:
		return m.PostNum()
	case post.FieldTitle:
		return m.Title()
	case post.FieldBody:
		return m.Body()
	case post.FieldDeadline:
		return m.Deadline()
	case post.FieldDeliveryDate:
		return m.DeliveryDate()
	case post.FieldLikeCount:
		return m.LikeCount()
	case post.FieldCommentCount:
		return m.CommentCount()
	case post.FieldOrderCount:
		return m.OrderCount()
	case post.FieldImages:
		return m.Images()
	case post.FieldStorageType:
		return m.StorageType()
	case post.FieldStatus:
		return m.Status()
	case post.FieldComment:
		return m.Comment()
	case post.FieldDelivered:
		return m.Delivered()
	case post.FieldIsInStock:
		return m.IsInStock()
	case post.FieldNormalTotal:
		return m.NormalTotal()
	case post.FieldNormalFee:
		return m.NormalFee()
	case post.FieldExtraTotal:
		return m.ExtraTotal()
	case post.FieldExtraFee:
		return m.ExtraFee()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldSellerID:
		return m.OldSellerID(ctx)
	case post.FieldPostNum:
		return m.OldPostNum(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldBody:
		return m.OldBody(ctx)
	case post.FieldDeadline:
		return m.OldDeadline(ctx)
	case post.FieldDeliveryDate:
		return m.OldDeliveryDate(ctx)
	case post.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case post.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case post.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case post.FieldImages:
		return m.OldImages(ctx)
	case post.FieldStorageType:
		return m.OldStorageType(ctx)
	case post.FieldStatus:
		return m.OldStatus(ctx)
	case post.FieldComment:
		return m.OldComment(ctx)
	case post.FieldDelivered:
		return m.OldDelivered(ctx)
	case post.FieldIsInStock:
		return m.OldIsInStock(ctx)
	case post.FieldNormalTotal:
		return m.OldNormalTotal(ctx)
	case post.FieldNormalFee:
		return m.OldNormalFee(ctx)
	case post.FieldExtraTotal:
		return m.OldExtraTotal(ctx)
	case post.FieldExtraFee:
		return m.OldExtraFee(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldSellerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellerID(v)
		return nil
	case post.FieldPostNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostNum(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case post.FieldDeadline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case post.FieldDeliveryDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryDate(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case post.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case post.FieldImages:
		v, ok := value.([]schema.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case post.FieldStorageType:
		v, ok := value.(post.StorageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(post.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case post.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case post.FieldDelivered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelivered(v)
		return nil
	case post.FieldIsInStock:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInStock(v)
		return nil
	case post.FieldNormalTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTotal(v)
		return nil
	case post.FieldNormalFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalFee(v)
		return nil
	case post.FieldExtraTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraTotal(v)
		return nil
	case post.FieldExtraFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraFee(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addpost_num != nil {
		fields = append(fields, post.FieldPostNum)
	}
	if m.addlike_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.addorder_count != nil {
		fields = append(fields, post.FieldOrderCount)
	}
	if m.addnormal_total != nil {
		fields = append(fields, post.FieldNormalTotal)
	}
	if m.addnormal_fee != nil {
		fields = append(fields, post.FieldNormalFee)
	}
	if m.addextra_total != nil {
		fields = append(fields, post.FieldExtraTotal)
	}
	if m.addextra_fee != nil {
		fields = append(fields, post.FieldExtraFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldPostNum:
		return m.AddedPostNum()
	case post.FieldLikeCount:
		return m.AddedLikeCount()
	case post.FieldCommentCount:
		return m.AddedCommentCount()
	case post.FieldOrderCount:
		return m.AddedOrderCount()
	case post.FieldNormalTotal:
		return m.AddedNormalTotal()
	case post.FieldNormalFee:
		return m.AddedNormalFee()
	case post.FieldExtraTotal:
		return m.AddedExtraTotal()
	case post.FieldExtraFee:
		return m.AddedExtraFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldPostNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostNum(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case post.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	case post.FieldNormalTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTotal(v)
		return nil
	case post.FieldNormalFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalFee(v)
		return nil
	case post.FieldExtraTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraTotal(v)
		return nil
	case post.FieldExtraFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraFee(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldSellerID:
		m.ResetSellerID()
		return nil
	case post.FieldPostNum:
		m.ResetPostNum()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldBody:
		m.ResetBody()
		return nil
	case post.FieldDeadline:
		m.ResetDeadline()
		return nil
	case post.FieldDeliveryDate:
		m.ResetDeliveryDate()
		return nil
	case post.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case post.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case post.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case post.FieldImages:
		m.ResetImages()
		return nil
	case post.FieldStorageType:
		m.ResetStorageType()
		return nil
	case post.FieldStatus:
		m.ResetStatus()
		return nil
	case post.FieldComment:
		m.ResetComment()
		return nil
	case post.FieldDelivered:
		m.ResetDelivered()
		return nil
	case post.FieldIsInStock:
		m.ResetIsInStock()
		return nil
	case post.FieldNormalTotal:
		m.ResetNormalTotal()
		return nil
	case post.FieldNormalFee:
		m.ResetNormalFee()
		return nil
	case post.FieldExtraTotal:
		m.ResetExtraTotal()
		return nil
	case post.FieldExtraFee:
		m.ResetExtraFee()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.seller != nil {
		edges = append(edges, post.EdgeSeller)
	}
	if m.post_comments != nil {
		edges = append(edges, post.EdgePostComments)
	}
	if m.post_delivers != nil {
		edges = append(edges, post.EdgePostDelivers)
	}
	if m.post_items != nil {
		edges = append(edges, post.EdgePostItems)
	}
	if m.post_likes != nil {
		edges = append(edges, post.EdgePostLikes)
	}
	if m.post_orders != nil {
		edges = append(edges, post.EdgePostOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeSeller:
		if id := m.seller; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePostComments:
		ids := make([]ent.Value, 0, len(m.post_comments))
		for id := range m.post_comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostDelivers:
		ids := make([]ent.Value, 0, len(m.post_delivers))
		for id := range m.post_delivers {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostItems:
		ids := make([]ent.Value, 0, len(m.post_items))
		for id := range m.post_items {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostLikes:
		ids := make([]ent.Value, 0, len(m.post_likes))
		for id := range m.post_likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostOrders:
		ids := make([]ent.Value, 0, len(m.post_orders))
		for id := range m.post_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedpost_comments != nil {
		edges = append(edges, post.EdgePostComments)
	}
	if m.removedpost_delivers != nil {
		edges = append(edges, post.EdgePostDelivers)
	}
	if m.removedpost_items != nil {
		edges = append(edges, post.EdgePostItems)
	}
	if m.removedpost_likes != nil {
		edges = append(edges, post.EdgePostLikes)
	}
	if m.removedpost_orders != nil {
		edges = append(edges, post.EdgePostOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgePostComments:
		ids := make([]ent.Value, 0, len(m.removedpost_comments))
		for id := range m.removedpost_comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostDelivers:
		ids := make([]ent.Value, 0, len(m.removedpost_delivers))
		for id := range m.removedpost_delivers {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostItems:
		ids := make([]ent.Value, 0, len(m.removedpost_items))
		for id := range m.removedpost_items {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostLikes:
		ids := make([]ent.Value, 0, len(m.removedpost_likes))
		for id := range m.removedpost_likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostOrders:
		ids := make([]ent.Value, 0, len(m.removedpost_orders))
		for id := range m.removedpost_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedseller {
		edges = append(edges, post.EdgeSeller)
	}
	if m.clearedpost_comments {
		edges = append(edges, post.EdgePostComments)
	}
	if m.clearedpost_delivers {
		edges = append(edges, post.EdgePostDelivers)
	}
	if m.clearedpost_items {
		edges = append(edges, post.EdgePostItems)
	}
	if m.clearedpost_likes {
		edges = append(edges, post.EdgePostLikes)
	}
	if m.clearedpost_orders {
		edges = append(edges, post.EdgePostOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeSeller:
		return m.clearedseller
	case post.EdgePostComments:
		return m.clearedpost_comments
	case post.EdgePostDelivers:
		return m.clearedpost_delivers
	case post.EdgePostItems:
		return m.clearedpost_items
	case post.EdgePostLikes:
		return m.clearedpost_likes
	case post.EdgePostOrders:
		return m.clearedpost_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeSeller:
		m.ClearSeller()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeSeller:
		m.ResetSeller()
		return nil
	case post.EdgePostComments:
		m.ResetPostComments()
		return nil
	case post.EdgePostDelivers:
		m.ResetPostDelivers()
		return nil
	case post.EdgePostItems:
		m.ResetPostItems()
		return nil
	case post.EdgePostLikes:
		m.ResetPostLikes()
		return nil
	case post.EdgePostOrders:
		m.ResetPostOrders()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostItemMutation represents an operation that mutates the PostItem nodes in the graph.
type PostItemMutation struct {
	config
	op               Op
	typ              string
	id               *string
	identifier       *string
	name             *string
	price            *float64
	addprice         *float64
	stock            *float64
	addstock         *float64
	clearedFields    map[string]struct{}
	post             *string
	clearedpost      bool
	post_item        map[string]struct{}
	removedpost_item map[string]struct{}
	clearedpost_item bool
	done             bool
	oldValue         func(context.Context) (*PostItem, error)
	predicates       []predicate.PostItem
}

var _ ent.Mutation = (*PostItemMutation)(nil)

// postitemOption allows management of the mutation configuration using functional options.
type postitemOption func(*PostItemMutation)

// newPostItemMutation creates new mutation for the PostItem entity.
func newPostItemMutation(c config, op Op, opts ...postitemOption) *PostItemMutation {
	m := &PostItemMutation{
		config:        c,
		op:            op,
		typ:           TypePostItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostItemID sets the ID field of the mutation.
func withPostItemID(id string) postitemOption {
	return func(m *PostItemMutation) {
		var (
			err   error
			once  sync.Once
			value *PostItem
		)
		m.oldValue = func(ctx context.Context) (*PostItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostItem sets the old PostItem of the mutation.
func withPostItem(node *PostItem) postitemOption {
	return func(m *PostItemMutation) {
		m.oldValue = func(context.Context) (*PostItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostItem entities.
func (m *PostItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPostID sets the "post_id" field.
func (m *PostItemMutation) SetPostID(s string) {
	m.post = &s
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *PostItemMutation) PostID() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the PostItem entity.
// If the PostItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostItemMutation) OldPostID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *PostItemMutation) ResetPostID() {
	m.post = nil
}

// SetIdentifier sets the "identifier" field.
func (m *PostItemMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *PostItemMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the PostItem entity.
// If the PostItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostItemMutation) OldIdentifier(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *PostItemMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetName sets the "name" field.
func (m *PostItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostItem entity.
// If the PostItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostItemMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *PostItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PostItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PostItem entity.
// If the PostItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostItemMutation) OldPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PostItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PostItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PostItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetStock sets the "stock" field.
func (m *PostItemMutation) SetStock(f float64) {
	m.stock = &f
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *PostItemMutation) Stock() (r float64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the PostItem entity.
// If the PostItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostItemMutation) OldStock(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds f to the "stock" field.
func (m *PostItemMutation) AddStock(f float64) {
	if m.addstock != nil {
		*m.addstock += f
	} else {
		m.addstock = &f
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *PostItemMutation) AddedStock() (r float64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *PostItemMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostItemMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[postitem.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *PostItemMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostItemMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostItemMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// AddPostItemIDs adds the "post_item" edge to the OrderItem entity by ids.
func (m *PostItemMutation) AddPostItemIDs(ids ...string) {
	if m.post_item == nil {
		m.post_item = make(map[string]struct{})
	}
	for i := range ids {
		m.post_item[ids[i]] = struct{}{}
	}
}

// ClearPostItem clears the "post_item" edge to the OrderItem entity.
func (m *PostItemMutation) ClearPostItem() {
	m.clearedpost_item = true
}

// PostItemCleared reports if the "post_item" edge to the OrderItem entity was cleared.
func (m *PostItemMutation) PostItemCleared() bool {
	return m.clearedpost_item
}

// RemovePostItemIDs removes the "post_item" edge to the OrderItem entity by IDs.
func (m *PostItemMutation) RemovePostItemIDs(ids ...string) {
	if m.removedpost_item == nil {
		m.removedpost_item = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_item, ids[i])
		m.removedpost_item[ids[i]] = struct{}{}
	}
}

// RemovedPostItem returns the removed IDs of the "post_item" edge to the OrderItem entity.
func (m *PostItemMutation) RemovedPostItemIDs() (ids []string) {
	for id := range m.removedpost_item {
		ids = append(ids, id)
	}
	return
}

// PostItemIDs returns the "post_item" edge IDs in the mutation.
func (m *PostItemMutation) PostItemIDs() (ids []string) {
	for id := range m.post_item {
		ids = append(ids, id)
	}
	return
}

// ResetPostItem resets all changes to the "post_item" edge.
func (m *PostItemMutation) ResetPostItem() {
	m.post_item = nil
	m.clearedpost_item = false
	m.removedpost_item = nil
}

// Where appends a list predicates to the PostItemMutation builder.
func (m *PostItemMutation) Where(ps ...predicate.PostItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostItem).
func (m *PostItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.post != nil {
		fields = append(fields, postitem.FieldPostID)
	}
	if m.identifier != nil {
		fields = append(fields, postitem.FieldIdentifier)
	}
	if m.name != nil {
		fields = append(fields, postitem.FieldName)
	}
	if m.price != nil {
		fields = append(fields, postitem.FieldPrice)
	}
	if m.stock != nil {
		fields = append(fields, postitem.FieldStock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postitem.FieldPostID:
		return m.PostID()
	case postitem.FieldIdentifier:
		return m.Identifier()
	case postitem.FieldName:
		return m.Name()
	case postitem.FieldPrice:
		return m.Price()
	case postitem.FieldStock:
		return m.Stock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postitem.FieldPostID:
		return m.OldPostID(ctx)
	case postitem.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case postitem.FieldName:
		return m.OldName(ctx)
	case postitem.FieldPrice:
		return m.OldPrice(ctx)
	case postitem.FieldStock:
		return m.OldStock(ctx)
	}
	return nil, fmt.Errorf("unknown PostItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postitem.FieldPostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case postitem.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case postitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case postitem.FieldStock:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	}
	return fmt.Errorf("unknown PostItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, postitem.FieldPrice)
	}
	if m.addstock != nil {
		fields = append(fields, postitem.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postitem.FieldPrice:
		return m.AddedPrice()
	case postitem.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case postitem.FieldStock:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown PostItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostItemMutation) ResetField(name string) error {
	switch name {
	case postitem.FieldPostID:
		m.ResetPostID()
		return nil
	case postitem.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case postitem.FieldName:
		m.ResetName()
		return nil
	case postitem.FieldPrice:
		m.ResetPrice()
		return nil
	case postitem.FieldStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown PostItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post != nil {
		edges = append(edges, postitem.EdgePost)
	}
	if m.post_item != nil {
		edges = append(edges, postitem.EdgePostItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postitem.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case postitem.EdgePostItem:
		ids := make([]ent.Value, 0, len(m.post_item))
		for id := range m.post_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpost_item != nil {
		edges = append(edges, postitem.EdgePostItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postitem.EdgePostItem:
		ids := make([]ent.Value, 0, len(m.removedpost_item))
		for id := range m.removedpost_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost {
		edges = append(edges, postitem.EdgePost)
	}
	if m.clearedpost_item {
		edges = append(edges, postitem.EdgePostItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostItemMutation) EdgeCleared(name string) bool {
	switch name {
	case postitem.EdgePost:
		return m.clearedpost
	case postitem.EdgePostItem:
		return m.clearedpost_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostItemMutation) ClearEdge(name string) error {
	switch name {
	case postitem.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostItemMutation) ResetEdge(name string) error {
	switch name {
	case postitem.EdgePost:
		m.ResetPost()
		return nil
	case postitem.EdgePostItem:
		m.ResetPostItem()
		return nil
	}
	return fmt.Errorf("unknown PostItem edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	_type                *room.Type
	name                 *string
	last_message         *string
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	room_messages        map[string]struct{}
	removedroom_messages map[string]struct{}
	clearedroom_messages bool
	room_users           map[string]struct{}
	removedroom_users    map[string]struct{}
	clearedroom_users    bool
	done                 bool
	oldValue             func(context.Context) (*Room, error)
	predicates           []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id string) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *RoomMutation) SetType(r room.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RoomMutation) GetType() (r room.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldType(ctx context.Context) (v room.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RoomMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
}

// SetLastMessage sets the "last_message" field.
func (m *RoomMutation) SetLastMessage(s string) {
	m.last_message = &s
}

// LastMessage returns the value of the "last_message" field in the mutation.
func (m *RoomMutation) LastMessage() (r string, exists bool) {
	v := m.last_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessage returns the old "last_message" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldLastMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessage: %w", err)
	}
	return oldValue.LastMessage, nil
}

// ResetLastMessage resets all changes to the "last_message" field.
func (m *RoomMutation) ResetLastMessage() {
	m.last_message = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoomMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoomMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoomMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRoomMessageIDs adds the "room_messages" edge to the Message entity by ids.
func (m *RoomMutation) AddRoomMessageIDs(ids ...string) {
	if m.room_messages == nil {
		m.room_messages = make(map[string]struct{})
	}
	for i := range ids {
		m.room_messages[ids[i]] = struct{}{}
	}
}

// ClearRoomMessages clears the "room_messages" edge to the Message entity.
func (m *RoomMutation) ClearRoomMessages() {
	m.clearedroom_messages = true
}

// RoomMessagesCleared reports if the "room_messages" edge to the Message entity was cleared.
func (m *RoomMutation) RoomMessagesCleared() bool {
	return m.clearedroom_messages
}

// RemoveRoomMessageIDs removes the "room_messages" edge to the Message entity by IDs.
func (m *RoomMutation) RemoveRoomMessageIDs(ids ...string) {
	if m.removedroom_messages == nil {
		m.removedroom_messages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_messages, ids[i])
		m.removedroom_messages[ids[i]] = struct{}{}
	}
}

// RemovedRoomMessages returns the removed IDs of the "room_messages" edge to the Message entity.
func (m *RoomMutation) RemovedRoomMessagesIDs() (ids []string) {
	for id := range m.removedroom_messages {
		ids = append(ids, id)
	}
	return
}

// RoomMessagesIDs returns the "room_messages" edge IDs in the mutation.
func (m *RoomMutation) RoomMessagesIDs() (ids []string) {
	for id := range m.room_messages {
		ids = append(ids, id)
	}
	return
}

// ResetRoomMessages resets all changes to the "room_messages" edge.
func (m *RoomMutation) ResetRoomMessages() {
	m.room_messages = nil
	m.clearedroom_messages = false
	m.removedroom_messages = nil
}

// AddRoomUserIDs adds the "room_users" edge to the RoomUser entity by ids.
func (m *RoomMutation) AddRoomUserIDs(ids ...string) {
	if m.room_users == nil {
		m.room_users = make(map[string]struct{})
	}
	for i := range ids {
		m.room_users[ids[i]] = struct{}{}
	}
}

// ClearRoomUsers clears the "room_users" edge to the RoomUser entity.
func (m *RoomMutation) ClearRoomUsers() {
	m.clearedroom_users = true
}

// RoomUsersCleared reports if the "room_users" edge to the RoomUser entity was cleared.
func (m *RoomMutation) RoomUsersCleared() bool {
	return m.clearedroom_users
}

// RemoveRoomUserIDs removes the "room_users" edge to the RoomUser entity by IDs.
func (m *RoomMutation) RemoveRoomUserIDs(ids ...string) {
	if m.removedroom_users == nil {
		m.removedroom_users = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_users, ids[i])
		m.removedroom_users[ids[i]] = struct{}{}
	}
}

// RemovedRoomUsers returns the removed IDs of the "room_users" edge to the RoomUser entity.
func (m *RoomMutation) RemovedRoomUsersIDs() (ids []string) {
	for id := range m.removedroom_users {
		ids = append(ids, id)
	}
	return
}

// RoomUsersIDs returns the "room_users" edge IDs in the mutation.
func (m *RoomMutation) RoomUsersIDs() (ids []string) {
	for id := range m.room_users {
		ids = append(ids, id)
	}
	return
}

// ResetRoomUsers resets all changes to the "room_users" edge.
func (m *RoomMutation) ResetRoomUsers() {
	m.room_users = nil
	m.clearedroom_users = false
	m.removedroom_users = nil
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, room.FieldType)
	}
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	if m.last_message != nil {
		fields = append(fields, room.FieldLastMessage)
	}
	if m.updated_at != nil {
		fields = append(fields, room.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldType:
		return m.GetType()
	case room.FieldName:
		return m.Name()
	case room.FieldLastMessage:
		return m.LastMessage()
	case room.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldType:
		return m.OldType(ctx)
	case room.FieldName:
		return m.OldName(ctx)
	case room.FieldLastMessage:
		return m.OldLastMessage(ctx)
	case room.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldType:
		v, ok := value.(room.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case room.FieldLastMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessage(v)
		return nil
	case room.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldType:
		m.ResetType()
		return nil
	case room.FieldName:
		m.ResetName()
		return nil
	case room.FieldLastMessage:
		m.ResetLastMessage()
		return nil
	case room.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room_messages != nil {
		edges = append(edges, room.EdgeRoomMessages)
	}
	if m.room_users != nil {
		edges = append(edges, room.EdgeRoomUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomMessages:
		ids := make([]ent.Value, 0, len(m.room_messages))
		for id := range m.room_messages {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeRoomUsers:
		ids := make([]ent.Value, 0, len(m.room_users))
		for id := range m.room_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroom_messages != nil {
		edges = append(edges, room.EdgeRoomMessages)
	}
	if m.removedroom_users != nil {
		edges = append(edges, room.EdgeRoomUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomMessages:
		ids := make([]ent.Value, 0, len(m.removedroom_messages))
		for id := range m.removedroom_messages {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeRoomUsers:
		ids := make([]ent.Value, 0, len(m.removedroom_users))
		for id := range m.removedroom_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom_messages {
		edges = append(edges, room.EdgeRoomMessages)
	}
	if m.clearedroom_users {
		edges = append(edges, room.EdgeRoomUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeRoomMessages:
		return m.clearedroom_messages
	case room.EdgeRoomUsers:
		return m.clearedroom_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeRoomMessages:
		m.ResetRoomMessages()
		return nil
	case room.EdgeRoomUsers:
		m.ResetRoomUsers()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoomUserMutation represents an operation that mutates the RoomUser nodes in the graph.
type RoomUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	last_read_message_id *string
	clearedFields        map[string]struct{}
	room                 *string
	clearedroom          bool
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*RoomUser, error)
	predicates           []predicate.RoomUser
}

var _ ent.Mutation = (*RoomUserMutation)(nil)

// roomuserOption allows management of the mutation configuration using functional options.
type roomuserOption func(*RoomUserMutation)

// newRoomUserMutation creates new mutation for the RoomUser entity.
func newRoomUserMutation(c config, op Op, opts ...roomuserOption) *RoomUserMutation {
	m := &RoomUserMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomUserID sets the ID field of the mutation.
func withRoomUserID(id string) roomuserOption {
	return func(m *RoomUserMutation) {
		var (
			err   error
			once  sync.Once
			value *RoomUser
		)
		m.oldValue = func(ctx context.Context) (*RoomUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoomUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomUser sets the old RoomUser of the mutation.
func withRoomUser(node *RoomUser) roomuserOption {
	return func(m *RoomUserMutation) {
		m.oldValue = func(context.Context) (*RoomUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoomUser entities.
func (m *RoomUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoomUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomID sets the "room_id" field.
func (m *RoomUserMutation) SetRoomID(s string) {
	m.room = &s
}

// RoomID returns the value of the "room_id" field in the mutation.
func (m *RoomUserMutation) RoomID() (r string, exists bool) {
	v := m.room
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomID returns the old "room_id" field's value of the RoomUser entity.
// If the RoomUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomUserMutation) OldRoomID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomID: %w", err)
	}
	return oldValue.RoomID, nil
}

// ResetRoomID resets all changes to the "room_id" field.
func (m *RoomUserMutation) ResetRoomID() {
	m.room = nil
}

// SetUserID sets the "user_id" field.
func (m *RoomUserMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RoomUserMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RoomUser entity.
// If the RoomUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomUserMutation) OldUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RoomUserMutation) ResetUserID() {
	m.user = nil
}

// SetLastReadMessageID sets the "last_read_message_id" field.
func (m *RoomUserMutation) SetLastReadMessageID(s string) {
	m.last_read_message_id = &s
}

// LastReadMessageID returns the value of the "last_read_message_id" field in the mutation.
func (m *RoomUserMutation) LastReadMessageID() (r string, exists bool) {
	v := m.last_read_message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadMessageID returns the old "last_read_message_id" field's value of the RoomUser entity.
// If the RoomUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomUserMutation) OldLastReadMessageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadMessageID: %w", err)
	}
	return oldValue.LastReadMessageID, nil
}

// ResetLastReadMessageID resets all changes to the "last_read_message_id" field.
func (m *RoomUserMutation) ResetLastReadMessageID() {
	m.last_read_message_id = nil
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *RoomUserMutation) ClearRoom() {
	m.clearedroom = true
	m.clearedFields[roomuser.FieldRoomID] = struct{}{}
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *RoomUserMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *RoomUserMutation) RoomIDs() (ids []string) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *RoomUserMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *RoomUserMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[roomuser.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RoomUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RoomUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RoomUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RoomUserMutation builder.
func (m *RoomUserMutation) Where(ps ...predicate.RoomUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoomUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoomUser).
func (m *RoomUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.room != nil {
		fields = append(fields, roomuser.FieldRoomID)
	}
	if m.user != nil {
		fields = append(fields, roomuser.FieldUserID)
	}
	if m.last_read_message_id != nil {
		fields = append(fields, roomuser.FieldLastReadMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomuser.FieldRoomID:
		return m.RoomID()
	case roomuser.FieldUserID:
		return m.UserID()
	case roomuser.FieldLastReadMessageID:
		return m.LastReadMessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomuser.FieldRoomID:
		return m.OldRoomID(ctx)
	case roomuser.FieldUserID:
		return m.OldUserID(ctx)
	case roomuser.FieldLastReadMessageID:
		return m.OldLastReadMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown RoomUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomuser.FieldRoomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomID(v)
		return nil
	case roomuser.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case roomuser.FieldLastReadMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown RoomUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoomUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoomUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomUserMutation) ResetField(name string) error {
	switch name {
	case roomuser.FieldRoomID:
		m.ResetRoomID()
		return nil
	case roomuser.FieldUserID:
		m.ResetUserID()
		return nil
	case roomuser.FieldLastReadMessageID:
		m.ResetLastReadMessageID()
		return nil
	}
	return fmt.Errorf("unknown RoomUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room != nil {
		edges = append(edges, roomuser.EdgeRoom)
	}
	if m.user != nil {
		edges = append(edges, roomuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomuser.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case roomuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom {
		edges = append(edges, roomuser.EdgeRoom)
	}
	if m.cleareduser {
		edges = append(edges, roomuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomUserMutation) EdgeCleared(name string) bool {
	switch name {
	case roomuser.EdgeRoom:
		return m.clearedroom
	case roomuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomUserMutation) ClearEdge(name string) error {
	switch name {
	case roomuser.EdgeRoom:
		m.ClearRoom()
		return nil
	case roomuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RoomUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomUserMutation) ResetEdge(name string) error {
	switch name {
	case roomuser.EdgeRoom:
		m.ResetRoom()
		return nil
	case roomuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown RoomUser edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	username                       *string
	display_name                   *string
	picture_url                    *string
	pickup_num                     *float64
	addpickup_num                  *float64
	role                           *user.Role
	status                         *user.Status
	notified                       *bool
	line_pay                       *bool
	fb                             *bool
	comment                        *string
	delivered_order_count_limit    *int
	adddelivered_order_count_limit *int
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	posts                          map[string]struct{}
	removedposts                   map[string]struct{}
	clearedposts                   bool
	user_comments                  map[string]struct{}
	removeduser_comments           map[string]struct{}
	cleareduser_comments           bool
	user_completes                 map[string]struct{}
	removeduser_completes          map[string]struct{}
	cleareduser_completes          bool
	user_delivers                  map[string]struct{}
	removeduser_delivers           map[string]struct{}
	cleareduser_delivers           bool
	user_likes                     map[string]struct{}
	removeduser_likes              map[string]struct{}
	cleareduser_likes              bool
	user_messages                  map[string]struct{}
	removeduser_messages           map[string]struct{}
	cleareduser_messages           bool
	user_orders                    map[string]struct{}
	removeduser_orders             map[string]struct{}
	cleareduser_orders             bool
	user_rooms                     map[string]struct{}
	removeduser_rooms              map[string]struct{}
	cleareduser_rooms              bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPictureURL sets the "picture_url" field.
func (m *UserMutation) SetPictureURL(s string) {
	m.picture_url = &s
}

// PictureURL returns the value of the "picture_url" field in the mutation.
func (m *UserMutation) PictureURL() (r string, exists bool) {
	v := m.picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPictureURL returns the old "picture_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPictureURL: %w", err)
	}
	return oldValue.PictureURL, nil
}

// ResetPictureURL resets all changes to the "picture_url" field.
func (m *UserMutation) ResetPictureURL() {
	m.picture_url = nil
}

// SetPickupNum sets the "pickup_num" field.
func (m *UserMutation) SetPickupNum(f float64) {
	m.pickup_num = &f
	m.addpickup_num = nil
}

// PickupNum returns the value of the "pickup_num" field in the mutation.
func (m *UserMutation) PickupNum() (r float64, exists bool) {
	v := m.pickup_num
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupNum returns the old "pickup_num" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPickupNum(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupNum: %w", err)
	}
	return oldValue.PickupNum, nil
}

// AddPickupNum adds f to the "pickup_num" field.
func (m *UserMutation) AddPickupNum(f float64) {
	if m.addpickup_num != nil {
		*m.addpickup_num += f
	} else {
		m.addpickup_num = &f
	}
}

// AddedPickupNum returns the value that was added to the "pickup_num" field in this mutation.
func (m *UserMutation) AddedPickupNum() (r float64, exists bool) {
	v := m.addpickup_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetPickupNum resets all changes to the "pickup_num" field.
func (m *UserMutation) ResetPickupNum() {
	m.pickup_num = nil
	m.addpickup_num = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v *user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v *user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetNotified sets the "notified" field.
func (m *UserMutation) SetNotified(b bool) {
	m.notified = &b
}

// Notified returns the value of the "notified" field in the mutation.
func (m *UserMutation) Notified() (r bool, exists bool) {
	v := m.notified
	if v == nil {
		return
	}
	return *v, true
}

// OldNotified returns the old "notified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotified(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotified: %w", err)
	}
	return oldValue.Notified, nil
}

// ResetNotified resets all changes to the "notified" field.
func (m *UserMutation) ResetNotified() {
	m.notified = nil
}

// SetLinePay sets the "line_pay" field.
func (m *UserMutation) SetLinePay(b bool) {
	m.line_pay = &b
}

// LinePay returns the value of the "line_pay" field in the mutation.
func (m *UserMutation) LinePay() (r bool, exists bool) {
	v := m.line_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldLinePay returns the old "line_pay" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLinePay(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinePay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinePay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinePay: %w", err)
	}
	return oldValue.LinePay, nil
}

// ResetLinePay resets all changes to the "line_pay" field.
func (m *UserMutation) ResetLinePay() {
	m.line_pay = nil
}

// SetFb sets the "fb" field.
func (m *UserMutation) SetFb(b bool) {
	m.fb = &b
}

// Fb returns the value of the "fb" field in the mutation.
func (m *UserMutation) Fb() (r bool, exists bool) {
	v := m.fb
	if v == nil {
		return
	}
	return *v, true
}

// OldFb returns the old "fb" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFb(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFb: %w", err)
	}
	return oldValue.Fb, nil
}

// ResetFb resets all changes to the "fb" field.
func (m *UserMutation) ResetFb() {
	m.fb = nil
}

// SetComment sets the "comment" field.
func (m *UserMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *UserMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *UserMutation) ResetComment() {
	m.comment = nil
}

// SetDeliveredOrderCountLimit sets the "delivered_order_count_limit" field.
func (m *UserMutation) SetDeliveredOrderCountLimit(i int) {
	m.delivered_order_count_limit = &i
	m.adddelivered_order_count_limit = nil
}

// DeliveredOrderCountLimit returns the value of the "delivered_order_count_limit" field in the mutation.
func (m *UserMutation) DeliveredOrderCountLimit() (r int, exists bool) {
	v := m.delivered_order_count_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredOrderCountLimit returns the old "delivered_order_count_limit" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeliveredOrderCountLimit(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredOrderCountLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredOrderCountLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredOrderCountLimit: %w", err)
	}
	return oldValue.DeliveredOrderCountLimit, nil
}

// AddDeliveredOrderCountLimit adds i to the "delivered_order_count_limit" field.
func (m *UserMutation) AddDeliveredOrderCountLimit(i int) {
	if m.adddelivered_order_count_limit != nil {
		*m.adddelivered_order_count_limit += i
	} else {
		m.adddelivered_order_count_limit = &i
	}
}

// AddedDeliveredOrderCountLimit returns the value that was added to the "delivered_order_count_limit" field in this mutation.
func (m *UserMutation) AddedDeliveredOrderCountLimit() (r int, exists bool) {
	v := m.adddelivered_order_count_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeliveredOrderCountLimit resets all changes to the "delivered_order_count_limit" field.
func (m *UserMutation) ResetDeliveredOrderCountLimit() {
	m.delivered_order_count_limit = nil
	m.adddelivered_order_count_limit = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddUserCommentIDs adds the "user_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddUserCommentIDs(ids ...string) {
	if m.user_comments == nil {
		m.user_comments = make(map[string]struct{})
	}
	for i := range ids {
		m.user_comments[ids[i]] = struct{}{}
	}
}

// ClearUserComments clears the "user_comments" edge to the Comment entity.
func (m *UserMutation) ClearUserComments() {
	m.cleareduser_comments = true
}

// UserCommentsCleared reports if the "user_comments" edge to the Comment entity was cleared.
func (m *UserMutation) UserCommentsCleared() bool {
	return m.cleareduser_comments
}

// RemoveUserCommentIDs removes the "user_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveUserCommentIDs(ids ...string) {
	if m.removeduser_comments == nil {
		m.removeduser_comments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_comments, ids[i])
		m.removeduser_comments[ids[i]] = struct{}{}
	}
}

// RemovedUserComments returns the removed IDs of the "user_comments" edge to the Comment entity.
func (m *UserMutation) RemovedUserCommentsIDs() (ids []string) {
	for id := range m.removeduser_comments {
		ids = append(ids, id)
	}
	return
}

// UserCommentsIDs returns the "user_comments" edge IDs in the mutation.
func (m *UserMutation) UserCommentsIDs() (ids []string) {
	for id := range m.user_comments {
		ids = append(ids, id)
	}
	return
}

// ResetUserComments resets all changes to the "user_comments" edge.
func (m *UserMutation) ResetUserComments() {
	m.user_comments = nil
	m.cleareduser_comments = false
	m.removeduser_comments = nil
}

// AddUserCompleteIDs adds the "user_completes" edge to the Complete entity by ids.
func (m *UserMutation) AddUserCompleteIDs(ids ...string) {
	if m.user_completes == nil {
		m.user_completes = make(map[string]struct{})
	}
	for i := range ids {
		m.user_completes[ids[i]] = struct{}{}
	}
}

// ClearUserCompletes clears the "user_completes" edge to the Complete entity.
func (m *UserMutation) ClearUserCompletes() {
	m.cleareduser_completes = true
}

// UserCompletesCleared reports if the "user_completes" edge to the Complete entity was cleared.
func (m *UserMutation) UserCompletesCleared() bool {
	return m.cleareduser_completes
}

// RemoveUserCompleteIDs removes the "user_completes" edge to the Complete entity by IDs.
func (m *UserMutation) RemoveUserCompleteIDs(ids ...string) {
	if m.removeduser_completes == nil {
		m.removeduser_completes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_completes, ids[i])
		m.removeduser_completes[ids[i]] = struct{}{}
	}
}

// RemovedUserCompletes returns the removed IDs of the "user_completes" edge to the Complete entity.
func (m *UserMutation) RemovedUserCompletesIDs() (ids []string) {
	for id := range m.removeduser_completes {
		ids = append(ids, id)
	}
	return
}

// UserCompletesIDs returns the "user_completes" edge IDs in the mutation.
func (m *UserMutation) UserCompletesIDs() (ids []string) {
	for id := range m.user_completes {
		ids = append(ids, id)
	}
	return
}

// ResetUserCompletes resets all changes to the "user_completes" edge.
func (m *UserMutation) ResetUserCompletes() {
	m.user_completes = nil
	m.cleareduser_completes = false
	m.removeduser_completes = nil
}

// AddUserDeliverIDs adds the "user_delivers" edge to the Deliver entity by ids.
func (m *UserMutation) AddUserDeliverIDs(ids ...string) {
	if m.user_delivers == nil {
		m.user_delivers = make(map[string]struct{})
	}
	for i := range ids {
		m.user_delivers[ids[i]] = struct{}{}
	}
}

// ClearUserDelivers clears the "user_delivers" edge to the Deliver entity.
func (m *UserMutation) ClearUserDelivers() {
	m.cleareduser_delivers = true
}

// UserDeliversCleared reports if the "user_delivers" edge to the Deliver entity was cleared.
func (m *UserMutation) UserDeliversCleared() bool {
	return m.cleareduser_delivers
}

// RemoveUserDeliverIDs removes the "user_delivers" edge to the Deliver entity by IDs.
func (m *UserMutation) RemoveUserDeliverIDs(ids ...string) {
	if m.removeduser_delivers == nil {
		m.removeduser_delivers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_delivers, ids[i])
		m.removeduser_delivers[ids[i]] = struct{}{}
	}
}

// RemovedUserDelivers returns the removed IDs of the "user_delivers" edge to the Deliver entity.
func (m *UserMutation) RemovedUserDeliversIDs() (ids []string) {
	for id := range m.removeduser_delivers {
		ids = append(ids, id)
	}
	return
}

// UserDeliversIDs returns the "user_delivers" edge IDs in the mutation.
func (m *UserMutation) UserDeliversIDs() (ids []string) {
	for id := range m.user_delivers {
		ids = append(ids, id)
	}
	return
}

// ResetUserDelivers resets all changes to the "user_delivers" edge.
func (m *UserMutation) ResetUserDelivers() {
	m.user_delivers = nil
	m.cleareduser_delivers = false
	m.removeduser_delivers = nil
}

// AddUserLikeIDs adds the "user_likes" edge to the Like entity by ids.
func (m *UserMutation) AddUserLikeIDs(ids ...string) {
	if m.user_likes == nil {
		m.user_likes = make(map[string]struct{})
	}
	for i := range ids {
		m.user_likes[ids[i]] = struct{}{}
	}
}

// ClearUserLikes clears the "user_likes" edge to the Like entity.
func (m *UserMutation) ClearUserLikes() {
	m.cleareduser_likes = true
}

// UserLikesCleared reports if the "user_likes" edge to the Like entity was cleared.
func (m *UserMutation) UserLikesCleared() bool {
	return m.cleareduser_likes
}

// RemoveUserLikeIDs removes the "user_likes" edge to the Like entity by IDs.
func (m *UserMutation) RemoveUserLikeIDs(ids ...string) {
	if m.removeduser_likes == nil {
		m.removeduser_likes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_likes, ids[i])
		m.removeduser_likes[ids[i]] = struct{}{}
	}
}

// RemovedUserLikes returns the removed IDs of the "user_likes" edge to the Like entity.
func (m *UserMutation) RemovedUserLikesIDs() (ids []string) {
	for id := range m.removeduser_likes {
		ids = append(ids, id)
	}
	return
}

// UserLikesIDs returns the "user_likes" edge IDs in the mutation.
func (m *UserMutation) UserLikesIDs() (ids []string) {
	for id := range m.user_likes {
		ids = append(ids, id)
	}
	return
}

// ResetUserLikes resets all changes to the "user_likes" edge.
func (m *UserMutation) ResetUserLikes() {
	m.user_likes = nil
	m.cleareduser_likes = false
	m.removeduser_likes = nil
}

// AddUserMessageIDs adds the "user_messages" edge to the Message entity by ids.
func (m *UserMutation) AddUserMessageIDs(ids ...string) {
	if m.user_messages == nil {
		m.user_messages = make(map[string]struct{})
	}
	for i := range ids {
		m.user_messages[ids[i]] = struct{}{}
	}
}

// ClearUserMessages clears the "user_messages" edge to the Message entity.
func (m *UserMutation) ClearUserMessages() {
	m.cleareduser_messages = true
}

// UserMessagesCleared reports if the "user_messages" edge to the Message entity was cleared.
func (m *UserMutation) UserMessagesCleared() bool {
	return m.cleareduser_messages
}

// RemoveUserMessageIDs removes the "user_messages" edge to the Message entity by IDs.
func (m *UserMutation) RemoveUserMessageIDs(ids ...string) {
	if m.removeduser_messages == nil {
		m.removeduser_messages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_messages, ids[i])
		m.removeduser_messages[ids[i]] = struct{}{}
	}
}

// RemovedUserMessages returns the removed IDs of the "user_messages" edge to the Message entity.
func (m *UserMutation) RemovedUserMessagesIDs() (ids []string) {
	for id := range m.removeduser_messages {
		ids = append(ids, id)
	}
	return
}

// UserMessagesIDs returns the "user_messages" edge IDs in the mutation.
func (m *UserMutation) UserMessagesIDs() (ids []string) {
	for id := range m.user_messages {
		ids = append(ids, id)
	}
	return
}

// ResetUserMessages resets all changes to the "user_messages" edge.
func (m *UserMutation) ResetUserMessages() {
	m.user_messages = nil
	m.cleareduser_messages = false
	m.removeduser_messages = nil
}

// AddUserOrderIDs adds the "user_orders" edge to the Order entity by ids.
func (m *UserMutation) AddUserOrderIDs(ids ...string) {
	if m.user_orders == nil {
		m.user_orders = make(map[string]struct{})
	}
	for i := range ids {
		m.user_orders[ids[i]] = struct{}{}
	}
}

// ClearUserOrders clears the "user_orders" edge to the Order entity.
func (m *UserMutation) ClearUserOrders() {
	m.cleareduser_orders = true
}

// UserOrdersCleared reports if the "user_orders" edge to the Order entity was cleared.
func (m *UserMutation) UserOrdersCleared() bool {
	return m.cleareduser_orders
}

// RemoveUserOrderIDs removes the "user_orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveUserOrderIDs(ids ...string) {
	if m.removeduser_orders == nil {
		m.removeduser_orders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_orders, ids[i])
		m.removeduser_orders[ids[i]] = struct{}{}
	}
}

// RemovedUserOrders returns the removed IDs of the "user_orders" edge to the Order entity.
func (m *UserMutation) RemovedUserOrdersIDs() (ids []string) {
	for id := range m.removeduser_orders {
		ids = append(ids, id)
	}
	return
}

// UserOrdersIDs returns the "user_orders" edge IDs in the mutation.
func (m *UserMutation) UserOrdersIDs() (ids []string) {
	for id := range m.user_orders {
		ids = append(ids, id)
	}
	return
}

// ResetUserOrders resets all changes to the "user_orders" edge.
func (m *UserMutation) ResetUserOrders() {
	m.user_orders = nil
	m.cleareduser_orders = false
	m.removeduser_orders = nil
}

// AddUserRoomIDs adds the "user_rooms" edge to the RoomUser entity by ids.
func (m *UserMutation) AddUserRoomIDs(ids ...string) {
	if m.user_rooms == nil {
		m.user_rooms = make(map[string]struct{})
	}
	for i := range ids {
		m.user_rooms[ids[i]] = struct{}{}
	}
}

// ClearUserRooms clears the "user_rooms" edge to the RoomUser entity.
func (m *UserMutation) ClearUserRooms() {
	m.cleareduser_rooms = true
}

// UserRoomsCleared reports if the "user_rooms" edge to the RoomUser entity was cleared.
func (m *UserMutation) UserRoomsCleared() bool {
	return m.cleareduser_rooms
}

// RemoveUserRoomIDs removes the "user_rooms" edge to the RoomUser entity by IDs.
func (m *UserMutation) RemoveUserRoomIDs(ids ...string) {
	if m.removeduser_rooms == nil {
		m.removeduser_rooms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_rooms, ids[i])
		m.removeduser_rooms[ids[i]] = struct{}{}
	}
}

// RemovedUserRooms returns the removed IDs of the "user_rooms" edge to the RoomUser entity.
func (m *UserMutation) RemovedUserRoomsIDs() (ids []string) {
	for id := range m.removeduser_rooms {
		ids = append(ids, id)
	}
	return
}

// UserRoomsIDs returns the "user_rooms" edge IDs in the mutation.
func (m *UserMutation) UserRoomsIDs() (ids []string) {
	for id := range m.user_rooms {
		ids = append(ids, id)
	}
	return
}

// ResetUserRooms resets all changes to the "user_rooms" edge.
func (m *UserMutation) ResetUserRooms() {
	m.user_rooms = nil
	m.cleareduser_rooms = false
	m.removeduser_rooms = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.picture_url != nil {
		fields = append(fields, user.FieldPictureURL)
	}
	if m.pickup_num != nil {
		fields = append(fields, user.FieldPickupNum)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.notified != nil {
		fields = append(fields, user.FieldNotified)
	}
	if m.line_pay != nil {
		fields = append(fields, user.FieldLinePay)
	}
	if m.fb != nil {
		fields = append(fields, user.FieldFb)
	}
	if m.comment != nil {
		fields = append(fields, user.FieldComment)
	}
	if m.delivered_order_count_limit != nil {
		fields = append(fields, user.FieldDeliveredOrderCountLimit)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldPictureURL:
		return m.PictureURL()
	case user.FieldPickupNum:
		return m.PickupNum()
	case user.FieldRole:
		return m.Role()
	case user.FieldStatus:
		return m.Status()
	case user.FieldNotified:
		return m.Notified()
	case user.FieldLinePay:
		return m.LinePay()
	case user.FieldFb:
		return m.Fb()
	case user.FieldComment:
		return m.Comment()
	case user.FieldDeliveredOrderCountLimit:
		return m.DeliveredOrderCountLimit()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldPictureURL:
		return m.OldPictureURL(ctx)
	case user.FieldPickupNum:
		return m.OldPickupNum(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldNotified:
		return m.OldNotified(ctx)
	case user.FieldLinePay:
		return m.OldLinePay(ctx)
	case user.FieldFb:
		return m.OldFb(ctx)
	case user.FieldComment:
		return m.OldComment(ctx)
	case user.FieldDeliveredOrderCountLimit:
		return m.OldDeliveredOrderCountLimit(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldPictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPictureURL(v)
		return nil
	case user.FieldPickupNum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupNum(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotified(v)
		return nil
	case user.FieldLinePay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinePay(v)
		return nil
	case user.FieldFb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFb(v)
		return nil
	case user.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case user.FieldDeliveredOrderCountLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredOrderCountLimit(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addpickup_num != nil {
		fields = append(fields, user.FieldPickupNum)
	}
	if m.adddelivered_order_count_limit != nil {
		fields = append(fields, user.FieldDeliveredOrderCountLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPickupNum:
		return m.AddedPickupNum()
	case user.FieldDeliveredOrderCountLimit:
		return m.AddedDeliveredOrderCountLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPickupNum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPickupNum(v)
		return nil
	case user.FieldDeliveredOrderCountLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveredOrderCountLimit(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldPictureURL:
		m.ResetPictureURL()
		return nil
	case user.FieldPickupNum:
		m.ResetPickupNum()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldNotified:
		m.ResetNotified()
		return nil
	case user.FieldLinePay:
		m.ResetLinePay()
		return nil
	case user.FieldFb:
		m.ResetFb()
		return nil
	case user.FieldComment:
		m.ResetComment()
		return nil
	case user.FieldDeliveredOrderCountLimit:
		m.ResetDeliveredOrderCountLimit()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.user_comments != nil {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.user_completes != nil {
		edges = append(edges, user.EdgeUserCompletes)
	}
	if m.user_delivers != nil {
		edges = append(edges, user.EdgeUserDelivers)
	}
	if m.user_likes != nil {
		edges = append(edges, user.EdgeUserLikes)
	}
	if m.user_messages != nil {
		edges = append(edges, user.EdgeUserMessages)
	}
	if m.user_orders != nil {
		edges = append(edges, user.EdgeUserOrders)
	}
	if m.user_rooms != nil {
		edges = append(edges, user.EdgeUserRooms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserComments:
		ids := make([]ent.Value, 0, len(m.user_comments))
		for id := range m.user_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCompletes:
		ids := make([]ent.Value, 0, len(m.user_completes))
		for id := range m.user_completes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDelivers:
		ids := make([]ent.Value, 0, len(m.user_delivers))
		for id := range m.user_delivers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserLikes:
		ids := make([]ent.Value, 0, len(m.user_likes))
		for id := range m.user_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMessages:
		ids := make([]ent.Value, 0, len(m.user_messages))
		for id := range m.user_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserOrders:
		ids := make([]ent.Value, 0, len(m.user_orders))
		for id := range m.user_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRooms:
		ids := make([]ent.Value, 0, len(m.user_rooms))
		for id := range m.user_rooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removeduser_comments != nil {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.removeduser_completes != nil {
		edges = append(edges, user.EdgeUserCompletes)
	}
	if m.removeduser_delivers != nil {
		edges = append(edges, user.EdgeUserDelivers)
	}
	if m.removeduser_likes != nil {
		edges = append(edges, user.EdgeUserLikes)
	}
	if m.removeduser_messages != nil {
		edges = append(edges, user.EdgeUserMessages)
	}
	if m.removeduser_orders != nil {
		edges = append(edges, user.EdgeUserOrders)
	}
	if m.removeduser_rooms != nil {
		edges = append(edges, user.EdgeUserRooms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserComments:
		ids := make([]ent.Value, 0, len(m.removeduser_comments))
		for id := range m.removeduser_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCompletes:
		ids := make([]ent.Value, 0, len(m.removeduser_completes))
		for id := range m.removeduser_completes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDelivers:
		ids := make([]ent.Value, 0, len(m.removeduser_delivers))
		for id := range m.removeduser_delivers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserLikes:
		ids := make([]ent.Value, 0, len(m.removeduser_likes))
		for id := range m.removeduser_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMessages:
		ids := make([]ent.Value, 0, len(m.removeduser_messages))
		for id := range m.removeduser_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserOrders:
		ids := make([]ent.Value, 0, len(m.removeduser_orders))
		for id := range m.removeduser_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRooms:
		ids := make([]ent.Value, 0, len(m.removeduser_rooms))
		for id := range m.removeduser_rooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.cleareduser_comments {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.cleareduser_completes {
		edges = append(edges, user.EdgeUserCompletes)
	}
	if m.cleareduser_delivers {
		edges = append(edges, user.EdgeUserDelivers)
	}
	if m.cleareduser_likes {
		edges = append(edges, user.EdgeUserLikes)
	}
	if m.cleareduser_messages {
		edges = append(edges, user.EdgeUserMessages)
	}
	if m.cleareduser_orders {
		edges = append(edges, user.EdgeUserOrders)
	}
	if m.cleareduser_rooms {
		edges = append(edges, user.EdgeUserRooms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeUserComments:
		return m.cleareduser_comments
	case user.EdgeUserCompletes:
		return m.cleareduser_completes
	case user.EdgeUserDelivers:
		return m.cleareduser_delivers
	case user.EdgeUserLikes:
		return m.cleareduser_likes
	case user.EdgeUserMessages:
		return m.cleareduser_messages
	case user.EdgeUserOrders:
		return m.cleareduser_orders
	case user.EdgeUserRooms:
		return m.cleareduser_rooms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeUserComments:
		m.ResetUserComments()
		return nil
	case user.EdgeUserCompletes:
		m.ResetUserCompletes()
		return nil
	case user.EdgeUserDelivers:
		m.ResetUserDelivers()
		return nil
	case user.EdgeUserLikes:
		m.ResetUserLikes()
		return nil
	case user.EdgeUserMessages:
		m.ResetUserMessages()
		return nil
	case user.EdgeUserOrders:
		m.ResetUserOrders()
		return nil
	case user.EdgeUserRooms:
		m.ResetUserRooms()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
